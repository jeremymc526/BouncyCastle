/*
 * NAI Send
 */
#include <nai_module_ext.h>
#include "NAIComms.h"
#include "cmd_naiconfigmsgutils.h"
#include "cmd_naiopermsgutils.h"
#include "cmd_naimsgutils.h"

#ifndef __UBOOT
#include <stdio.h>
#else
#include <common.h>
#include <malloc.h>
#endif

extern void* aligned_malloc(size_t size, size_t alignment);
extern void aligned_free(void* p);

#define NAI_MODULE_QSPI_TEST_OFFSET 0x600000
void create_nai_test_sequence_1(uint8_t ucTargetModuleSlot, MsgList* ptMsgList)
{
	int32_t nNumMessages = 1; /* 3; */
//	uint32_t unTestMsgPayloadWordLength = 512; 
	uint32_t unTestMsgPayloadWordLength = 255; 
	int32_t i = 0, nMsg = 0;		
	int32_t nMsgPacketCount = 0;
	int32_t lPayloadWordsLeftToRead = 0;
	int32_t nPayloadWordCount = 0;
	uint16_t usPayloadValue = 0;
	MsgPacketList *ptMsgPacketList = NULL;
	uint16_t usID = 0;
	uint16_t usExpectedSequenceCount = 0;
	uint8_t ucCompleterID = ucTargetModuleSlot;
	uint8_t ucRequesterID = MB_SLOT;	

#ifdef _VERBOSE
	snprintf("RequesterID: 0x%4x  CompleterID: 0x%4x\r\n", ucRequesterID, ucCompleterID);
#endif

	for (nMsg = 0; nMsg < nNumMessages; nMsg++)
	{
		ptMsgPacketList = create_nai_msg_packet_list();

		nMsgPacketCount = 0;		
		lPayloadWordsLeftToRead = (int32_t)unTestMsgPayloadWordLength;
		usID++;

		/* Determine expected sequence count...NOTE this takes into account all header info */
		usExpectedSequenceCount = calculate_nai_expected_sequence_count(unTestMsgPayloadWordLength);

		do
		{		
			nMsgPacketCount++;
			NAIMsg tNAIMsg;		
			memset(&tNAIMsg, 0, sizeof(NAIMsg));

			/* SERDES HEADER */
			tNAIMsg.tSerdesHdr.ucToHPS = 1;
			tNAIMsg.tSerdesHdr.ucType = 3;			
   		    tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
			tNAIMsg.tSerdesHdr.usSERDES2 = 0;
			tNAIMsg.tSerdesHdr.usSERDES3 = 0;
			tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
			tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
			tNAIMsg.tSerdesHdr.usSERDES5 = 0;

			/* Serdes Payload length must be a multiple of 2 */
			if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
				tNAIMsg.tSerdesHdr.ucPayloadLength++;

			/* TRANSPORT HEADER */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
			tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = (unTestMsgPayloadWordLength + (usExpectedSequenceCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS));    /* Length in Words */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
			tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

			/* COMMAND HEADER */
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x0;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_WRITEFLASH;			
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = NAI_MODULE_QSPI_TEST_OFFSET;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = 0x0;

			/* COMMAND PAYLOAD */
#ifdef _VERBOSE
			printf("Num Msg Words To Read: %ld\r\n", lPayloadWordsLeftToRead);
#endif
			nPayloadWordCount = MIN(lPayloadWordsLeftToRead, CONFIG_MAX_PAYLOAD_IN_WORDS);
			for (i=0; i < nPayloadWordCount; i++)
			   tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i] = usPayloadValue++;

			tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = (nPayloadWordCount * 2); /*Packet payload length stored in bytes */	

			/* Let's build a linked list of message packets that will represent a full message */
			create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
			lPayloadWordsLeftToRead -= nPayloadWordCount;
#ifdef _VERBOSE
			printf("Num Msg Words Left To Read: %ld\r\n", lPayloadWordsLeftToRead);		
#endif

		} while (lPayloadWordsLeftToRead > 0);

		/* traverse_nai_msg_packets(ptMsgPacketList); */
		add_nai_msg(ptMsgList, ptMsgPacketList);
	}
}

void create_nai_test_sequence_2(uint8_t ucTargetModuleSlot, uint32_t unPayload, MsgList* ptMsgList)
{
	int32_t nNumMessages = 1;
	uint32_t unTestMsgPayloadWordLength = unPayload; //1120; /* # of words to write */
//	uint32_t unTestMsgPayloadWordLength = 250; /* # of words to write */
	int32_t i = 0, nMsg = 0;		
	int32_t nMsgPacketCount = 0;
	int32_t lPayloadWordsLeftToRead = 0;
	int32_t nPayloadWordCount = 0;
	uint16_t usPayloadValue = 0;
	MsgPacketList *ptMsgPacketList = NULL;
	uint16_t usID = 0;
	uint16_t usExpectedSequenceCount = 0;
	uint8_t ucCompleterID = ucTargetModuleSlot;
	uint8_t ucRequesterID = MB_SLOT;

	for (nMsg = 0; nMsg < nNumMessages; nMsg++)
	{
		ptMsgPacketList = create_nai_msg_packet_list();

		nMsgPacketCount = 0;		
		lPayloadWordsLeftToRead = (int32_t)unTestMsgPayloadWordLength;		
		usID++;

		/* Determine expected sequence count...NOTE this takes into account all header info */
		usExpectedSequenceCount = calculate_nai_expected_sequence_count(unTestMsgPayloadWordLength);

		do
		{		
			nMsgPacketCount++;
			NAIMsg tNAIMsg;		
			memset(&tNAIMsg, 0, sizeof(NAIMsg));

			/* SERDES HEADER */
			tNAIMsg.tSerdesHdr.ucToHPS = 1;
			tNAIMsg.tSerdesHdr.ucType = 3;
			tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
			tNAIMsg.tSerdesHdr.usSERDES2 = 0;
			tNAIMsg.tSerdesHdr.usSERDES3 = 0;
			tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
			tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
			tNAIMsg.tSerdesHdr.usSERDES5 = 0;

			/* Serdes Payload length must be a multiple of 2 */
			if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
				tNAIMsg.tSerdesHdr.ucPayloadLength++;

			/* TRANSPORT HEADER */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
			tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = (unTestMsgPayloadWordLength + (usExpectedSequenceCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS));    /* Length in Words */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
			tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

			/* COMMAND HEADER */
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x0;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_WRITEFLASH;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = NAI_MODULE_QSPI_TEST_OFFSET;
  		    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = 0x0;

			/* COMMAND PAYLOAD */
#ifdef _VERBOSE
			printf("Num Msg Words To Read: %ld\r\n", lPayloadWordsLeftToRead);
#endif
			nPayloadWordCount = MIN(lPayloadWordsLeftToRead, CONFIG_MAX_PAYLOAD_IN_WORDS);
			usPayloadValue++;
			for (i=0; i < nPayloadWordCount; i++)
			   tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i] = usPayloadValue;			

			tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = (nPayloadWordCount * 2); /*Packet payload length stored in bytes */

			/* Let's build a linked list of message packets that will represent a full message */
			create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
			lPayloadWordsLeftToRead -= nPayloadWordCount;
#ifdef _VERBOSE
			printf("Num Msg Words Left To Read: %ld\r\n", lPayloadWordsLeftToRead);			
#endif

		} while (lPayloadWordsLeftToRead > 0);

		/* traverse_nai_msg_packets(ptMsgPacketList); */
		add_nai_msg(ptMsgList, ptMsgPacketList);
	}

	/* Create Retrieve Request */
	ptMsgPacketList = create_nai_msg_packet_list();

	nMsgPacketCount = 0;		
	lPayloadWordsLeftToRead = 0;		
	usID++;

	/* Determine expected sequence count...NOTE this takes into account all header info */
	usExpectedSequenceCount = 1;

	nMsgPacketCount++;
	NAIMsg tNAIMsg;		
	memset(&tNAIMsg, 0, sizeof(NAIMsg));

	/* SERDES HEADER */
	tNAIMsg.tSerdesHdr.ucToHPS = 1;
	tNAIMsg.tSerdesHdr.ucType = 3;	
	tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
	tNAIMsg.tSerdesHdr.usSERDES2 = 0;
	tNAIMsg.tSerdesHdr.usSERDES3 = 0;
	tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
	tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
	tNAIMsg.tSerdesHdr.usSERDES5 = 0;

	/* Serdes Payload length must be a multiple of 2 */
	if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
		tNAIMsg.tSerdesHdr.ucPayloadLength++;

	/* TRANSPORT HEADER */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
	tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = CONFIG_TOTAL_PKT_HDR_IN_WORDS;    /* Length in Words - Single Packet Request with no payload!*/
	tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
	tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

	/* COMMAND HEADER */
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x0;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_READFLASH;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = NAI_MODULE_QSPI_TEST_OFFSET;
    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = (unTestMsgPayloadWordLength * 2);

	/* COMMAND PAYLOAD */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = 0; /*Packet payload length stored in bytes - No Payload since just a request */

	/* Let's build a linked list of message packets that will represent a full message */
	create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);

	/* traverse_nai_msg_packets(ptMsgPacketList); */
	add_nai_msg(ptMsgList, ptMsgPacketList);
}

void create_nai_test_sequence_3(uint8_t ucTargetModuleSlot, MsgList* ptMsgList)
{
	int32_t nNumMessages = 6;
	uint32_t unTestMsgPayloadWordLength = 25;
	int32_t i = 0, nMsg = 0;		
	int32_t nMsgPacketCount = 0;
	int32_t lPayloadWordsLeftToRead = 0;
	int32_t nPayloadWordCount = 0;
	uint16_t usPayloadValue = 0;
	MsgPacketList *ptMsgPacketList = NULL;
	uint16_t usID = 0;
	uint16_t usExpectedSequenceCount = 0;
	uint8_t ucCompleterID = ucTargetModuleSlot;
	uint8_t ucRequesterID = MB_SLOT;

	for (nMsg = 0; nMsg < nNumMessages; nMsg++)
	{			
		switch(nMsg)
		{
			case 0 : unTestMsgPayloadWordLength = 25;
					 break;
			case 1 : unTestMsgPayloadWordLength = 310;
					 break;
			case 2 : unTestMsgPayloadWordLength = 50;
					 break;
			case 3 : unTestMsgPayloadWordLength = 75;
					 break;
			case 4 : unTestMsgPayloadWordLength = 236; /*EQUALS 1 Full SERDES Packet*/
					 break;
			case 5 : unTestMsgPayloadWordLength = 708; /*EQUALS 3 Full SERDES Packets*/
					 break;
		};

		ptMsgPacketList = create_nai_msg_packet_list();

		nMsgPacketCount = 0;	
		usPayloadValue = 0;	
		lPayloadWordsLeftToRead = (int32_t)unTestMsgPayloadWordLength;		
		usID++;
		
		/* Determine expected sequence count...NOTE this takes into account all header info */
		usExpectedSequenceCount = calculate_nai_expected_sequence_count(unTestMsgPayloadWordLength);

		do
		{		
			nMsgPacketCount++;
			NAIMsg tNAIMsg;		
			memset(&tNAIMsg, 0, sizeof(NAIMsg));

			/* SERDES HEADER */
			tNAIMsg.tSerdesHdr.ucToHPS = 1;
			tNAIMsg.tSerdesHdr.ucType = 3;			
			tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
			tNAIMsg.tSerdesHdr.usSERDES2 = 0;
			tNAIMsg.tSerdesHdr.usSERDES3 = 0;
			tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
			tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
			tNAIMsg.tSerdesHdr.usSERDES5 = 0;
			
			/* Serdes Payload length must be a multiple of 2 */
			if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
				tNAIMsg.tSerdesHdr.ucPayloadLength++;

			/* TRANSPORT HEADER */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
			tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = (unTestMsgPayloadWordLength + (usExpectedSequenceCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS));    /* Length in Words */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
			tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

			/* COMMAND HEADER */
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x0;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_WRITEFLASH;			
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = NAI_MODULE_QSPI_TEST_OFFSET;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = 0x0;

			/* COMMAND PAYLOAD */
#ifdef _VERBOSE
			printf("Num Msg Payload Words To Read: %ld\r\n", lPayloadWordsLeftToRead);			
#endif

			nPayloadWordCount = MIN(lPayloadWordsLeftToRead, CONFIG_MAX_PAYLOAD_IN_WORDS);
			for (i=0; i < nPayloadWordCount; i++)
			   tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i] = usPayloadValue++;

			tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = (nPayloadWordCount * 2); /*Packet payload length stored in bytes */

			/* Let's build a linked list of message packets that will represent a full message */
			create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
			lPayloadWordsLeftToRead -= nPayloadWordCount;
#ifdef _VERBOSE
			printf("Num Msg Payload Words Left To Read: %ld\r\n", lPayloadWordsLeftToRead);			
#endif

		} while (lPayloadWordsLeftToRead > 0);

		/* traverse_nai_msg_packets(ptMsgPacketList); */
		add_nai_msg(ptMsgList, ptMsgPacketList);	
	}
}

/* This test will be used to test writing to and reading from EEPROM */
void create_nai_test_sequence_4(uint8_t ucTargetModuleSlot, MsgList* ptMsgList)
{
	int32_t nNumMessages = 1;
	uint32_t unTestMsgPayloadWordLength = 16; /* # of words to write */
	int32_t i = 0, nMsg = 0;		
	int32_t nMsgPacketCount = 0;
	int32_t lPayloadWordsLeftToRead = 0;
	int32_t nPayloadWordCount = 0;
	uint16_t usPayloadValue = 0;
	MsgPacketList *ptMsgPacketList = NULL;
	uint16_t usID = 0;
	uint16_t usExpectedSequenceCount = 0;
	uint8_t ucCompleterID = ucTargetModuleSlot;
	uint8_t ucRequesterID = MB_SLOT;

//#ifdef _DANT
	for (nMsg = 0; nMsg < nNumMessages; nMsg++)
	{
		ptMsgPacketList = create_nai_msg_packet_list();

		nMsgPacketCount = 0;		
		lPayloadWordsLeftToRead = (int32_t)unTestMsgPayloadWordLength;		
		usID++;

		/* Determine expected sequence count...NOTE this takes into account all header info */
		usExpectedSequenceCount = calculate_nai_expected_sequence_count(unTestMsgPayloadWordLength);

		do
		{		
			nMsgPacketCount++;
			NAIMsg tNAIMsg;		
			memset(&tNAIMsg, 0, sizeof(NAIMsg));

			/* SERDES HEADER */
			tNAIMsg.tSerdesHdr.ucToHPS = 1;
			tNAIMsg.tSerdesHdr.ucType = 3;			
			tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
			tNAIMsg.tSerdesHdr.usSERDES2 = 0;
			tNAIMsg.tSerdesHdr.usSERDES3 = 0;
			tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
			tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;		
			tNAIMsg.tSerdesHdr.usSERDES5 = 0;

			/* Serdes Payload length must be a multiple of 2 */
			if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
				tNAIMsg.tSerdesHdr.ucPayloadLength++;

			/* TRANSPORT HEADER */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
			tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = (unTestMsgPayloadWordLength + (usExpectedSequenceCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS));    /* Length in Words */
			tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
			tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

			/* COMMAND HEADER */
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x50;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_WRITEEEPROM;
			tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = 0x0;
  		    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = 0x0;

			/* COMMAND PAYLOAD */
#ifdef _VERBOSE
		    printf("Num Msg Words To Read: %ld\r\n", lPayloadWordsLeftToRead);
#endif
			nPayloadWordCount = MIN(lPayloadWordsLeftToRead, CONFIG_MAX_PAYLOAD_IN_WORDS);
			
			for (i=0; i < nPayloadWordCount; i++)
			{
				usPayloadValue++;
			   	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i] = usPayloadValue;			
			}

			tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = (nPayloadWordCount * 2); /*Packet payload length stored in bytes */

			/* Let's build a linked list of message packets that will represent a full message */
			create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
			lPayloadWordsLeftToRead -= nPayloadWordCount;
#ifdef _VERBOSE
			printf("Num Msg Words Left To Read: %ld\r\n", lPayloadWordsLeftToRead);
#endif

		} while (lPayloadWordsLeftToRead > 0);

		/* traverse_nai_msg_packets(ptMsgPacketList); */
		add_nai_msg(ptMsgList, ptMsgPacketList);
	}
//#endif
//#ifdef _DANT
	/* Create Retrieve Request */
	ptMsgPacketList = create_nai_msg_packet_list();

	nMsgPacketCount = 0;		
	lPayloadWordsLeftToRead = 0;		
	usID++;

	/* Determine expected sequence count...NOTE this takes into account all header info */
	usExpectedSequenceCount = 1;

	nMsgPacketCount++;
	NAIMsg tNAIMsg;		
	memset(&tNAIMsg, 0, sizeof(NAIMsg));

	/* SERDES HEADER */
	tNAIMsg.tSerdesHdr.ucToHPS = 1;
	tNAIMsg.tSerdesHdr.ucType = 3;	
	tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
	tNAIMsg.tSerdesHdr.usSERDES2 = 0;
	tNAIMsg.tSerdesHdr.usSERDES3 = 0;
	tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
	tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
	tNAIMsg.tSerdesHdr.usSERDES5 = 0;

	/* Serdes Payload length must be a multiple of 2 */
	if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
		tNAIMsg.tSerdesHdr.ucPayloadLength++;

	/* TRANSPORT HEADER */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
	tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = CONFIG_TOTAL_PKT_HDR_IN_WORDS;    /* Length in Words - Single Packet Request with no payload!*/
	tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
	tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

	/* COMMAND HEADER */
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x50;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_READEEPROM;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = 0x0;
    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = (unTestMsgPayloadWordLength * 2);

	/* COMMAND PAYLOAD */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = 0; /*Packet payload length stored in bytes - No Payload since just a request */

	/* Let's build a linked list of message packets that will represent a full message */
	create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);

	/* traverse_nai_msg_packets(ptMsgPacketList); */
	add_nai_msg(ptMsgList, ptMsgPacketList);
//#endif

}

void create_nai_test_module_qspi(uint8_t ucTargetModuleSlot, MsgList* ptMsgList)
{
	uint32_t unTestMsgPayloadWordLength = 0; /* # of words to write */		
	int32_t nMsgPacketCount = 0;
	int32_t lPayloadWordsLeftToRead = 0;
	MsgPacketList *ptMsgPacketList = NULL;
	uint16_t usID = 0;
	uint16_t usExpectedSequenceCount = 0;
	uint8_t ucCompleterID = ucTargetModuleSlot;
	uint8_t ucRequesterID = MB_SLOT;

	/* Create Retrieve Request */
	ptMsgPacketList = create_nai_msg_packet_list();

	nMsgPacketCount = 0;		
	lPayloadWordsLeftToRead = 0;		
	usID++;

	/* Determine expected sequence count...NOTE this takes into account all header info */
	usExpectedSequenceCount = 1;

	nMsgPacketCount++;
	NAIMsg tNAIMsg;		
	memset(&tNAIMsg, 0, sizeof(NAIMsg));

	/* SERDES HEADER */
	tNAIMsg.tSerdesHdr.ucToHPS = 1;
	tNAIMsg.tSerdesHdr.ucType = 3;	
	tNAIMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN((lPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
	tNAIMsg.tSerdesHdr.usSERDES2 = 0;
	tNAIMsg.tSerdesHdr.usSERDES3 = 0;
	tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
	tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
	tNAIMsg.tSerdesHdr.usSERDES5 = 0;

	/* Serdes Payload length must be a multiple of 2 */
	if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
		tNAIMsg.tSerdesHdr.ucPayloadLength++;

	/* TRANSPORT HEADER */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
	tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = CONFIG_TOTAL_PKT_HDR_IN_WORDS;    /* Length in Words - Single Packet Request with no payload!*/
	tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
	tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;

	/* COMMAND HEADER */
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0x0;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_DEBUG;
	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = 0x0;
    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = (unTestMsgPayloadWordLength * 2);

	/* COMMAND PAYLOAD */
	tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = 0; /*Packet payload length stored in bytes - No Payload since just a request */

	/* Let's build a linked list of message packets that will represent a full message */
	create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);

	/* traverse_nai_msg_packets(ptMsgPacketList); */
	add_nai_msg(ptMsgList, ptMsgPacketList);
}

/*********************************************************************/
/* Send Desired Messages Here!										 */
/*********************************************************************/
int do_naisend(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{	
#ifdef _DANT	
	MsgList tMsgList;
#endif	
	uint8_t ucTargetModuleSlot = MODULE_1_SLOT;
	uint32_t nStatus = NAI_SUCCESS;
	
#ifdef _DANT	
	uint32_t unPayload = 50;
#endif
	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 10);

#ifdef _DANT
	if (argc == 3)
		unPayload = (uint32_t)simple_strtoul (argv[2], NULL, 10);
#endif

	nai_init_msg_utils(MB_SLOT); /* Assigns MB ID */

#ifdef _DANT
	/* Execute module qspi test */
	init_nai_msgs(&tMsgList);
	create_nai_test_module_qspi(ucTargetModuleSlot, &tMsgList);
	nai_send_msgs(&tMsgList);
	delete_nai_msgs(&tMsgList);	
#endif
#ifdef _DANT
	/* Execute Test Sequence 1 */
	printf("======================================================\r\n");
	printf("BEGIN RUNNING TEST SEQUENCE 1: SIMPLE WRITE FLASH\r\n");
	init_nai_msgs(&tMsgList);
	create_nai_test_sequence_1(ucTargetModuleSlot, &tMsgList);
	nStatus = nai_send_msgs(&tMsgList);
	if (nStatus != NAI_SUCCESS)
		printf("ERROR TEST SEQUENCE 1: %d\r\n", nStatus);
	delete_nai_msgs(&tMsgList);	
	printf("END RUNNING TEST SEQUENCE 1: SIMPLE WRITE FLASH\r\n");
	printf("======================================================\r\n");
	
	/* Execute Test Sequence 2 */
	printf("======================================================\r\n");	
	printf("BEGIN RUNNING TEST SEQUENCE 2: WRITE FLASH FOLLOWED BY READ FLASH\r\n");
	init_nai_msgs(&tMsgList);
	create_nai_test_sequence_2(ucTargetModuleSlot, unPayload, &tMsgList);
	nStatus = nai_erase_flash_request(MB_SLOT, ucTargetModuleSlot, NAI_MODULE_QSPI_TEST_OFFSET, 1);
	if (nStatus != NAI_SUCCESS)
		printf("ERROR TEST SEQUENCE 2 - Erasing Flash Problem: %d\r\n", nStatus);			
#ifdef _VERBOSE			
	printf("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n");
	printf("BEFORE SEND MSG LIST PRINTOUT TO FOLLOW:\r\n");
	printf("--------------------------------------------------------------------\r\n");
	print_nai_msgs(&tMsgList, TRUE);
	printf("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n");
#endif	
	nStatus = nai_send_msgs(&tMsgList);
	if (nStatus != NAI_SUCCESS)
		printf("ERROR TEST SEQUENCE 2: %d\r\n", nStatus);
	delete_nai_msgs(&tMsgList);	

	/* Try to receive response message */
	if (nStatus == NAI_SUCCESS)
	{
		printf("<><><><><><><><><><><><><><><><><><><><><><><><><><><><><>\r\n");
		while (!nai_rx_fifo_pkt_ready(ASSIGNED_SLOT_ID, ucTargetModuleSlot))
			;
		init_nai_msgs(&tMsgList);
		do
		{
			if (nai_rx_fifo_pkt_ready(ASSIGNED_SLOT_ID, ucTargetModuleSlot))
			{
				nStatus = nai_receive_msg_packet(ASSIGNED_SLOT_ID, ucTargetModuleSlot, &tMsgList);
				if (nStatus != NAI_SUCCESS)
					break;
			}
		} while	(tMsgList.ptEnd->unWordsLeftToRead > 0);

		if (nStatus != NAI_SUCCESS)
			printf("ERROR TEST SEQUENCE 2B: %d\r\n", nStatus);
		print_nai_msgs(&tMsgList, TRUE);
		validate_nai_msgs(&tMsgList);
		delete_nai_msgs(&tMsgList);
	}
	printf("END RUNNING TEST SEQUENCE 2: WRITE FLASH FOLLOWED BY READ FLASH\r\n");
	printf("======================================================\r\n");

	/* Execute Test Sequence 3 */
	printf("======================================================\r\n");
	printf("BEGIN RUNNING TEST SEQUENCE 3: MULTI MSG MULTI PACKET WRITE FLASH\r\n");
	init_nai_msgs(&tMsgList);
	create_nai_test_sequence_3(ucTargetModuleSlot, &tMsgList);
	nStatus = nai_send_msgs(&tMsgList);
	if (nStatus != NAI_SUCCESS)
		printf("ERROR TEST SEQUENCE 3: %d\r\n", nStatus);
	delete_nai_msgs(&tMsgList);	
	printf("END RUNNING TEST SEQUENCE 3: MULTI MSG MULTI PACKET WRITE FLASH\r\n");
	printf("======================================================\r\n");
//#endif

	/* Execute Test Sequence 4 */
	printf("======================================================\r\n");
	printf("BEGIN RUNNING TEST SEQUENCE 4: WRITE EEPROM FOLLOWED BY READ EEPROM\r\n");
	init_nai_msgs(&tMsgList);
	create_nai_test_sequence_4(ucTargetModuleSlot, &tMsgList);
	nStatus = nai_send_msgs(&tMsgList);
	if (nStatus != NAI_SUCCESS)
		printf("ERROR TEST SEQUENCE 4 (SEND): %d\r\n", nStatus);
	delete_nai_msgs(&tMsgList);	

	/* Try to receive response message */
	printf("<><><><><><><><><><><><><><><><><><><><><><><><><><><><><>\r\n");
	if (nStatus == NAI_SUCCESS)
	{
		while (!nai_rx_fifo_pkt_ready(ASSIGNED_SLOT_ID, ucTargetModuleSlot))
			;

		init_nai_msgs(&tMsgList);
		do
		{
			if (nai_rx_fifo_pkt_ready(ASSIGNED_SLOT_ID, ucTargetModuleSlot))
			{
				nStatus = nai_receive_msg_packet(ASSIGNED_SLOT_ID, ucTargetModuleSlot, &tMsgList);
				if (nStatus != NAI_SUCCESS)
					break;
			}

		} while	(tMsgList.ptEnd->unWordsLeftToRead > 0);

		if (nStatus != NAI_SUCCESS)
			printf("ERROR TEST SEQUENCE 4 (RECEIVE): %d\r\n", nStatus);
		print_nai_msgs(&tMsgList, TRUE);
		validate_nai_msgs(&tMsgList);
		delete_nai_msgs(&tMsgList);
	}
	printf("END RUNNING TEST SEQUENCE 4: WRITE EEPROM FOLLOWED BY READ EEPROM\r\n");
	printf("======================================================\r\n");
#endif
//#ifdef _DANT
	printf("======================================================\r\n");
	printf("BEGIN WRITE - READ - VERIFY FLASH\r\n");
	/* Higher Level API Test */
	uint8_t pTemp[65536]; 
	uint8_t pTempRead[65536];
//	uint8_t pTemp[10000]; 
//	uint8_t pTempRead[10000];

	int i = 0;
	int k = 0;
	int nLen = 0x10000; /*65536*/
//	int nLen = 10000; 
	uint32_t nLoopCnt = 5;
	uint32_t unOffset = NAI_MODULE_QSPI_TEST_OFFSET;
//	uint32_t unPrevBytesWritten = 0;
	uint32_t unFailures = 0;
	BOOL bMisMatch = FALSE;

	if (argc == 3)
		nLoopCnt = (uint32_t)simple_strtoul (argv[2], NULL, 10);

	for (i=0; i < nLoopCnt; i++)
	{
		memset(pTemp, 0, nLen);
		memset(pTempRead, 0, nLen);

		nStatus = nai_erase_flash_request(MB_SLOT, ucTargetModuleSlot, unOffset, 1);
		if (nStatus != NAI_SUCCESS)
		{
			printf("*****************************************************\r\n");
			printf("nai_erase_flash_request ERROR: %d\r\n", nStatus);
			printf("*****************************************************\r\n");
			break;
		}

/*DANT
		if (i == (nLoopCnt -1))
			nLen = 500;
//				nLen = 2125;
*/
		for (k=0; k < nLen; k++)			
			pTemp[k] = k;	

//		unOffset = ((i%256) * nLen);
//		unOffset += unPrevBytesWritten;

		printf("nai_write_module_flash_request  [%d  of  %d]\r\n", i+1, nLoopCnt);
		nStatus = nai_write_module_flash_request(MB_SLOT, ucTargetModuleSlot, unOffset, &(pTemp[0]), nLen);
	
		if (nStatus != NAI_SUCCESS)
		{
			printf("*****************************************************\r\n");
			printf("nai_write_module_flash_request ERROR: %d\r\n", nStatus);
			printf("*****************************************************\r\n");
			break;
		}

//		unPrevBytesWritten = nLen;

		printf("About to Read Back\r\n");

		nStatus = nai_read_module_flash_request(MB_SLOT, ucTargetModuleSlot, unOffset, &(pTempRead[0]), nLen);
		if (nStatus != NAI_SUCCESS)
		{
			printf("*****************************************************\r\n");
			printf("nai_read_module_flash_request ERROR: %d\r\n", nStatus);
			printf("*****************************************************\r\n");
			break;
		}

		bMisMatch = FALSE;
		for (k=0; k < nLen; k++)
		{		
//			printf("pTemp[%d] = %4.4x  pTempRead[%d] = %4.4x\r\n", k, pTemp[k], k, pTempRead[k]);	

			if (pTemp[k] != pTempRead[k])
			{
				unFailures++;
				printf("pTemp[%d] = %4.4x  pTempRead[%d] = %4.4x\r\n", k, pTemp[k], k, pTempRead[k]);
				bMisMatch = TRUE;
				break;
			}				
		}

		if (bMisMatch)
			printf("Data Validation for [%d of %d] = FAILED\r\n", i+1, nLoopCnt);
		else
			printf("Data Validation for [%d of %d] = PASSED\r\n", i+1, nLoopCnt);

		printf("Total Number of Failures: %u\r\n", unFailures);
		printf("-----------------------------------------------------\r\n");			

	}
	printf("END WRITE - READ - VERIFY FLASH\r\n");
	printf("======================================================\r\n");	
//#endif

	printf("End of cmd_naisend!\r\n");	
	return 0;
}

int do_naiwritereg32(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unAddress = 0x0;
	uint32_t unValue = 0x0;	
	
	if (argc == 3)
	{
		unAddress = (uint32_t)simple_strtoul (argv[1], NULL, 16);
		unValue = (uint32_t)simple_strtoul (argv[2], NULL, 16);		
	}

	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_write_reg32_request with: \r\nAddress = 0x%x Value = 0x%x\r\n", unAddress, unValue);
	nStatus = nai_write_reg32_request(unAddress, unValue);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_reg32_request - Status = %d\r\n", nStatus);
	printf("End of do_naiwritereg32!\r\n");
	return 0;
}

int do_naiwritereg32byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{	
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffset = 0x0;
	uint32_t unValue = 0x0;	

	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	if (argc >= 3)
		unModuleOffset = (uint32_t)simple_strtoul (argv[2], NULL, 16);

	if (argc >= 4)
		unValue = (uint32_t)simple_strtoul (argv[3], NULL, 16);	
	
	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_write_reg32_by_slot_request with: \r\nSlotID = 0x%x ModuleOffset = 0x%x Value = 0x%x\r\n", ucTargetModuleSlot, unModuleOffset, unValue);
	nStatus = nai_write_reg32_by_slot_request(ucTargetModuleSlot, unModuleOffset, unValue);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_reg32_by_slot_request - Status = %d\r\n", nStatus);
	printf("End of do_naiwritereg32byslot!\r\n");
	return 0;
}

int do_naireadreg32(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unAddress = 0x0;
	uint32_t unValue = 0x0;	

	if (argc == 2)
		unAddress = (uint32_t)simple_strtoul (argv[1], NULL, 16);

	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_read_reg32_request with: \r\nAddress = 0x%x\r\n", unAddress);
	nStatus = nai_read_reg32_request(unAddress, &unValue);	

	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_reg32_request - Status = %d\r\n", nStatus);
	else
		printf("Value = 0x%x (%u)\r\n", unValue, unValue);
	
	printf("End of do_naireadreg32!\r\n");
	return 0;
}

int do_naireadreg32byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffset = 0x0;
	uint32_t unValue = 0x0;	

	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	if (argc >= 3)
		unModuleOffset = (uint32_t)simple_strtoul (argv[2], NULL, 16);

	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_read_reg32_by_slot_request with: \r\nSlotID = 0x%x ModuleOffset = 0x%x\r\n", ucTargetModuleSlot, unModuleOffset);
	nStatus = nai_read_reg32_by_slot_request(ucTargetModuleSlot, unModuleOffset, &unValue);	

	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_reg32_by_slot_request - Status = %d\r\n", nStatus);
	else
		printf("Value = 0x%x (%u)\r\n", unValue, unValue);
	
	printf("End of do_naireadreg32byslot!\r\n");
	return 0;
}

int do_naiwritereg16(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unAddress = 0x0;
	uint16_t usValue = 0x0;	
	
	if (argc == 3)
	{
		unAddress = (uint32_t)simple_strtoul (argv[1], NULL, 16);
		usValue = (uint16_t)simple_strtoul (argv[2], NULL, 16);		
	}

	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_write_reg16_request with: \r\nAddress = 0x%x Value = 0x%x\r\n", unAddress, usValue);
	nStatus = nai_write_reg16_request(unAddress, usValue);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_reg16_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwritereg16!\r\n");
	return 0;
}

int do_naireadreg16(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unAddress = 0x0;
	uint16_t usValue = 0x0;	

	if (argc == 2)
		unAddress = (uint32_t)simple_strtoul (argv[1], NULL, 16);

	nai_init_msg_utils(MB_SLOT);
	printf("Calling nai_read_reg16_request with: \r\nAddress = 0x%x\r\n", unAddress);
	nStatus = nai_read_reg16_request(unAddress, &usValue);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_reg32_request - Status = %d\r\n", nStatus);
	else
		printf("Value = 0x%x (%u)\r\n", usValue, usValue);
	
	printf("End of do_naireadreg16!\r\n");
	return 0;
}

int do_naiwriteblock32(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint32_t unValue[255];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc > 4)
	{
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);

		for (i = 0; i < usCount; i++)
			unValue[i] = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
	}
	
	printf("Calling nai_write_block32_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);
	for (i = 0; i < usCount; i++)
		printf("Value[%u] = 0x%x (%u)\r\n", i, unValue[i], unValue[i]);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block32_request(unStartAddress, usCount, ucStride, &unValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block32_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwriteblock32!\r\n");
	return 0;
}

int do_naiwriteblock32byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffsetStart = 0x0;
	uint32_t unValue[255];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc > 5)
	{
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		unModuleOffsetStart = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);

		for (i = 0; i < usCount; i++)
			unValue[i] = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
	}
	
	printf("Calling nai_write_block32_by_slot_request with: \r\nSlotID = 0x%x StartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", ucTargetModuleSlot, unModuleOffsetStart, ucStride, usCount);
	for (i = 0; i < usCount; i++)
		printf("Value[%u] = 0x%x (%u)\r\n", i, unValue[i], unValue[i]);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block32_by_slot_request(ucTargetModuleSlot, unModuleOffsetStart, usCount, ucStride, &unValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block32_by_slot_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwriteblock32byslot!\r\n");
	return 0;
}

int do_naireadblock32(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint32_t unValue[1024];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc >= 3)
	{
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	}
	
	printf("Calling nai_read_block32_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_read_block32_request(unStartAddress, usCount, ucStride, &unValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_block32_request - Status = %d\r\n", nStatus);
	else
	{
		for (i = 0; i < usCount; i++)
			printf("Value[%u] = 0x%x (%u)\r\n", i, unValue[i], unValue[i]);
	}
	printf("End of do_naireadblock32!\r\n");
	return 0;
}

int do_naireadblock32byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffsetStart = 0x0;
	uint32_t unValue[1024];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc >= 4)
	{
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		unModuleOffsetStart = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	}
	
	printf("Calling nai_read_block32_by_slot_request with: \r\nSlotID = 0x%x ModuleOffsetStart = 0x%x Stride = 0x%x Count = 0x%x\r\n", ucTargetModuleSlot, unModuleOffsetStart, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_read_block32_by_slot_request(ucTargetModuleSlot, unModuleOffsetStart, usCount, ucStride, &unValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_block32_by_slot_request - Status = %d\r\n", nStatus);
	else
	{
		for (i = 0; i < usCount; i++)
			printf("Value[%u] = 0x%x (%u)\r\n", i, unValue[i], unValue[i]);
	}
	printf("End of do_naireadblock32byslot!\r\n");
	return 0;
}

int do_naiwriteblock16(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint16_t usValue[255];
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc > 4)
	{
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);

		for (i = 0; i < usCount; i++)
			usValue[i] = (uint16_t)simple_strtoul(argv[usArgIndex++], NULL, 16);
	}
	
	printf("Calling nai_write_block16_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);
	for (i = 0; i < usCount; i++)
		printf("Value[%u] = 0x%x (%u)\r\n", i, usValue[i], usValue[i]);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block16_request(unStartAddress, usCount, ucStride, &usValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block16_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwriteblock16!\r\n");
	return 0;
}

int do_naiwriteblock16byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffsetStart = 0x0;
	uint16_t usValue[255];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc > 5)
	{
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		unModuleOffsetStart = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);

		for (i = 0; i < usCount; i++)
			usValue[i] = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
	}
	
	printf("Calling nai_write_block16_by_slot_request with: \r\nSlotID = 0x%x StartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", ucTargetModuleSlot, unModuleOffsetStart, ucStride, usCount);
	for (i = 0; i < usCount; i++)
		printf("Value[%u] = 0x%x (%u)\r\n", i, usValue[i], usValue[i]);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block16_by_slot_request(ucTargetModuleSlot, unModuleOffsetStart, usCount, ucStride, &usValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block16_by_slot_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwriteblock16byslot!\r\n");
	return 0;
}

int do_naiwriteblock16byslotauto(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffsetStart = 0x0;
	uint16_t usValue[1024];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc > 4)
	{
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		unModuleOffsetStart = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);

		for (i = 0; i < usCount; i++)
			usValue[i] = (uint16_t)(i+1);
	}
	
	printf("Calling nai_write_block16_by_slot_request with: \r\nSlotID = 0x%x StartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", ucTargetModuleSlot, unModuleOffsetStart, ucStride, usCount);
//	for (i = 0; i < usCount; i++)
//		printf("Value[%u] = 0x%x (%u)\r\n", i, usValue[i], usValue[i]);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block16_by_slot_request(ucTargetModuleSlot, unModuleOffsetStart, usCount, ucStride, &usValue[0]);
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block16_by_slot_request - Status = %d\r\n", nStatus);

	printf("End of do_naiwriteblock16byslotauto!\r\n");
	return 0;
}

int do_naireadblock16(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint16_t usValue[1024];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc >= 3)
	{
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	}
	
	printf("Calling nai_read_block16_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_read_block16_request(unStartAddress, usCount, ucStride, &usValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_block16_request - Status = %d\r\n", nStatus);
	else
	{
		for (i = 0; i < usCount; i++)
			printf("Value[%u] = 0x%x (%u)\r\n", i, usValue[i], usValue[i]);
	}
	printf("End of do_naireadblock16!\r\n");
	return 0;
}

int do_naireadblock16byslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint8_t ucTargetModuleSlot = 1;
	uint32_t unModuleOffsetStart = 0x0;
	uint16_t usValue[1024];	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	
	if (argc >= 4)
	{
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		unModuleOffsetStart = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	}
	
	printf("Calling nai_read_block16_by_slot_request with: \r\nSlotID = 0x%x ModuleOffsetStart = 0x%x Stride = 0x%x Count = 0x%x\r\n", ucTargetModuleSlot, unModuleOffsetStart, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_read_block16_by_slot_request(ucTargetModuleSlot, unModuleOffsetStart, usCount, ucStride, &usValue[0]);
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_block16_by_slot_request - Status = %d\r\n", nStatus);
	else
	{
		for (i = 0; i < usCount; i++)
			printf("Value[%u] = 0x%x (%u)\r\n", i, usValue[i], usValue[i]);
	}
	printf("End of do_naireadblock16byslot!\r\n");
	return 0;
}

int do_naiforcemoduleslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{	
	uint8_t ucTargetModuleSlot = 0;

	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	nai_init_msg_utils(MB_SLOT);
	nai_perform_init_slot_addressing();
	nai_assign_hard_coded_module_slot(ucTargetModuleSlot);
	return 0;
}

int do_naimoduleprobe(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	uint32_t nRetryCount = 0;
	uint32_t nMaxRetryAttemps = 40;
	uint32_t nMaxPowerUpDelay = 250;
	uint32_t nMaxModuleSlot	  = 7;	
	uint32_t nModuleDetectReg = 0;
	uint32_t nModuleLinkReg = 0;
	uint32_t nLinkBitMask = 0;
	uint32_t nDetectBitMask = 0;
	uint32_t nReadyBitMask = 0;
	uint32_t nBitPos = 0;
	uint32_t ulTimer = 0;
	uint32_t nStatus = 0;
	printf("Probe Module Slote....\r\n");
	nStatus = nai_init_as_slot(MB_SLOT);
	if (nStatus != NAI_SUCCESS)
	{
		printf("Failed to initialize nai module\r\n");
		return nStatus;
	}	
	/*time out after 10 seconds*/
	/* Read mod_detect_status for 1 module */
	while (nRetryCount < nMaxRetryAttemps)
	{
		nModuleDetectReg = nai_read32(0x0100);
		if (nModuleDetectReg != 0)
		{
			printf("Module Detect Status = 0x%08x\n", nModuleDetectReg);
			break;
		}

		ulTimer = nai_get_timer(0);
		while (nai_get_timer(ulTimer) < nMaxPowerUpDelay)
		  ;
		nRetryCount++;
	}
	
	if (nRetryCount >= nMaxRetryAttemps)
	{
	     printf("FAILED to detect enabled state for module\n");
	} 
	else 
	{
		printf("-------------------------------------\n");	
		printf("\nModule is now READY!\n");

		/* Wait until mod_link_init_status is ready */	
		printf("-------------------------------------\n");	
		/*time out after 10 seconds*/
		nRetryCount = 0;
		while (nRetryCount < nMaxRetryAttemps)
		{
			nModuleLinkReg = nai_read32(0x0104);
			if (nModuleLinkReg != 0)
			{
				printf("Module Link Init Status = 0x%08x\n", nModuleLinkReg);
				break;
			}
				ulTimer = nai_get_timer(0);
				while (nai_get_timer(ulTimer) < nMaxPowerUpDelay)
						;
				nRetryCount++;
		}
		
		if (nRetryCount >= nMaxRetryAttemps)
		{
		  printf("FAILED to detect Ready state for mod_link_init_status\n");
		}
		else
		{
			printf("-------------------------------------\n");	
			printf("*** SERDES LINK IS UP AND READY! ***\n");
			printf("-------------------------------------\n");
			
			for ( nBitPos = 0; nBitPos < nMaxModuleSlot; nBitPos++ )
			{
				/*Module detects status register is a 16bits 
				 * upper 8 bits module detect 
				 * lower 8 bits module ready
				 */
				nDetectBitMask = (1 << (nBitPos + 8));
				nReadyBitMask = (1 << nBitPos);
				
				nLinkBitMask = (1 << nBitPos);
				if( (nModuleDetectReg & nDetectBitMask) && (nModuleDetectReg & nReadyBitMask) && (nModuleLinkReg & nLinkBitMask) )
				{
					printf("Module %d Ready \n",nBitPos+1);
				}
				
				nLinkBitMask = 0;
				nDetectBitMask = 0;
				nReadyBitMask = 0;
			}
		}
	}
	
	return nStatus;
}

int do_exitmodconfigmode(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	uint8_t ucTargetModuleSlot = 0;
	uint32_t nStatus = NAI_SUCCESS;

	nai_init_msg_utils(MB_SLOT);
	nai_init_all_module_slots(6);

	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	nStatus = nai_exit_module_config_mode_request(ucTargetModuleSlot);
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_exit_module_config_mode_request - Status = %d\r\n", nStatus);

	return 0;
}

int do_resetmodule(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{

#ifdef CONFIG_NAI_MODULE_SUPPORT

	uint8_t ucTargetModuleSlot = 0;
	uint32_t nStatus = NAI_MODULE_SUCCESS;
	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	//module slot index id start from 0
	ucTargetModuleSlot -= 1; 
	if(ucTargetModuleSlot >= 0){
		//nStatus = nai_module_reset(ucTargetModuleSlot);
		/*updated module reset call from nai_module_ext.h*/
		nai_module_reset();
		if (nStatus != NAI_MODULE_SUCCESS)
			printf("Failed nai_module_reset - Status = %d\r\n", nStatus);
	} else {
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot+1);
	}
#else
	uint8_t ucTargetModuleSlot = 0;
	uint32_t nStatus = NAI_SUCCESS;

	nai_init_msg_utils(MB_SLOT);
	nai_init_all_module_slots(6);

	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	nStatus = nai_reset_module_request(ucTargetModuleSlot);
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_reset_module_request - Status = %d\r\n", nStatus);
#endif
	return 0;
}
int do_enablemodule(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
#ifdef CONFIG_NAI_MODULE_SUPPORT
	uint8_t ucTargetModuleSlot = 0;
	uint32_t nStatus = NAI_MODULE_SUCCESS;
	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	//module slot index id start from 0
	ucTargetModuleSlot -= 1; 
	if(ucTargetModuleSlot >= 0){
	
	//nStatus = nai_enable_module_board(ucTargetModuleSlot);
	/*updated module enable call from nai_module_ext.h*/
	nai_enable_module();
	
	if (nStatus != NAI_MODULE_SUCCESS)
			printf("Failed Enable Module - Status = %d\r\n", nStatus);
	} else {
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot+1);
	}
	
#endif	
	return 0;
}
int do_initmodule(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{

#ifdef CONFIG_NAI_MODULE_SUPPORT
	//nai_init_module_board();
	/*updated module init call from nai_module_ext.h*/
	nai_init_module();
#endif	
	return 0;
}

int do_disablemodule(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{

#ifdef CONFIG_NAI_MODULE_SUPPORT
	uint8_t ucTargetModuleSlot = 0;
	uint32_t nStatus = NAI_MODULE_SUCCESS;
	if (argc == 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	//module slot index id start from 0
	ucTargetModuleSlot -= 1; 
	if(ucTargetModuleSlot >= 0){
	
	//nStatus = nai_disable_module_board(ucTargetModuleSlot);
	/*updated module disalbe call from nai_module_ext.h*/
	nai_disable_module();
	
	if (nStatus != NAI_MODULE_SUCCESS)
			printf("Failed Disable Module - Status = %d\r\n", nStatus);
	} else {
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot+1);
	}
	
#endif	
	return 0;
}

int do_eraseflash(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	uint8_t ucTargetModuleSlot = 0;
	uint32_t unOffset = 0;
	uint8_t ucNumPages = 0;
	uint32_t nStatus = NAI_SUCCESS;

	nai_init_msg_utils(MB_SLOT);
	nai_init_all_module_slots(6);

	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);

	if (argc >= 3)
		unOffset = (uint32_t)simple_strtoul (argv[2], NULL, 16);

	if (argc >= 4)
		ucNumPages = (uint32_t)simple_strtoul (argv[3], NULL, 16);

	nStatus = nai_erase_flash_request(MB_SLOT, ucTargetModuleSlot, unOffset, ucNumPages);
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_erase_flash_request - Status = %d\r\n", nStatus);

	return 0;
}

int do_testwrite(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint32_t* punValue;	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 1;	
	uint32_t unStartValue = 0;
	
	if (argc > 1)		
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		
    if (argc > 2)
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 3)
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 4)
		unStartValue = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		
	if (usCount > 0)
		punValue = (uint32_t*)malloc(sizeof(uint32_t)*usCount);
	else
		return -1;

	for (i = 0; i < usCount; i++)
		punValue[i] = (uint32_t)(unStartValue + i);

	printf("nai_write_reg32_by_slot_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	
	for (i=0; i < usCount; i++)
	{
		nai_write_reg32_by_slot_request(1, unStartAddress, punValue[i]);
		unStartAddress += (ucStride * 4);
	}
			
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_reg32_by_slot_request - Status = %d\r\n", nStatus);

	printf("End of do_naitestwrite!\r\n");
	
	free(punValue);
	return 0;
}

int do_testwriteblock(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint32_t* punValue;	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;	
	uint32_t unStartValue = 0;
	
	if (argc > 1)		
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		
    if (argc > 2)
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 3)
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 4)
		unStartValue = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		
	if (usCount > 0)
		punValue = (uint32_t*)malloc(sizeof(uint32_t)*usCount);
	else
		return -1;

	for (i = 0; i < usCount; i++)
		punValue[i] = (uint32_t)(unStartValue + i);

	printf("Calling nai_write_block32_by_slot_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_write_block32_by_slot_request(1, unStartAddress, usCount, ucStride, &punValue[0]);
	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_write_block32_request - Status = %d\r\n", nStatus);

	printf("End of do_naitestwriteblock!\r\n");
	
	free(punValue);
	return 0;
}

int do_testreadblock(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int32_t nStatus = NAI_SUCCESS;
	uint32_t unStartAddress = 0x0;
	uint32_t* punValue;	
	uint16_t usCount = 0;
	uint16_t i = 0;
	uint16_t usArgIndex = 1;
	uint8_t ucStride = 0;
	uint16_t usMismatchCount = 0;
	uint32_t unStartValue = 0;
	
	if (argc > 1)
		unStartAddress = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);
		
	if (argc > 2)
		ucStride = (uint8_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 3)
		usCount = (uint16_t)simple_strtoul (argv[usArgIndex++], NULL, 10);
	
	if (argc > 4)
		unStartValue = (uint32_t)simple_strtoul (argv[usArgIndex++], NULL, 16);	
	
	if (usCount > 0)
		punValue = (uint32_t*)malloc(sizeof(uint32_t)*usCount);
	else
		return -1;
		
	printf("Calling nai_read_block32_request with: \r\nStartAddress = 0x%x Stride = 0x%x Count = 0x%x\r\n", unStartAddress, ucStride, usCount);

	nai_init_msg_utils(MB_SLOT);
	nStatus = nai_read_block32_by_slot_request(1, unStartAddress, usCount, ucStride, &punValue[0]);	
	if (nStatus != NAI_SUCCESS)
		printf("Failed nai_read_block32_request - Status = %d\r\n", nStatus);
	else
	{
		printf("Comparing Data Values...\r\n");
		for (i = 0; i < usCount; i++)
		{
			if ((punValue[i] & 0x0FF) != ((unStartValue+i) & 0x0FF))//(i%0xFF))
			{
				usMismatchCount++;
				printf("Value[%u] = (%u)\r\n", i, punValue[i]);
			}
		}
		if (usMismatchCount > 0)
			printf("**********COMPARISON FAILED!!!**********\r\n");
		else
			printf("**********COMPARISON PASSED!!!**********\r\n");
	}		
	printf("End of do_testreadblock!\r\n");
	
	free(punValue);
	return 0;
}

int do_naitestdtconfigbyslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
//#ifdef CONFIG_NAI_MODULE_SUPPORT	
	uint8_t ucRequesterID = MB_SLOT;
	uint8_t ucTargetModuleSlot = 0;	
	uint8_t ucChannel = 1;
	uint32_t nStatus = NAI_MODULE_SUCCESS;	
			 
#ifdef _ST	  
	uint32_t unOffset = 0x00008000;	/* Flash program memory start for STM8L_16 */
	const uint8_t ucDataBuf[1577] = {
	0x82,0x00,0x85,0xee,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x82,0x00,0x86,0x19,0x00,0x85,0xd0,0x00,0x0d,0x00,0x10,0x00,0x00,0x00,0x85,0x8a,0x00,0x04,0x80,0x99,0x00,0x0c,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x7f,0xff,0x80,0x00,0x72,0x12,0x50,0xc9,0x72,0x5f,0x50,0xc0,0x35,0x01,0x50,0xc8,0x72,0x00,0x50,0xc9,0xfb,0x72,0x14,0x50,0xc3,0x72,0x5f,0x52,0xe8,0x35,0x10,0x52,0xe9,0x35,0x0a,0x52,0xe7,0x72,0x10,0x50,0xc4,0x72,0x5f,0x53,0x40,0x72,0x5f,0x53,0x41,0x35,0x1f,0x53,0x42,0x35,0xff,0x53,0x43,0x35,0x0f,0x53,0x46,0x35,0xff,0x53,0x47,0x72,0x5f,0x53,0x48,0x72,0x5f,0x53,0x49,0x72,0x5f,0x53,0x4a,0x72,0x5f,0x53,0x4b,0x72,0x5f,0x53,0x4c,0x72,0x5f,0x53,0x4d,0x72,0x5f,0x53,0x4e,0x72,0x5f,0x53,0x4f,0x72,0x5f,0x53,0x50,0x72,0x5f,0x53,0x51,0x72,0x10,0x53,0x40,0xc6,0x53,0x40,0xa4,0x9b,0xc7,0x53,0x40,0xc6,0x53,0x40,0xc7,0x53,0x40,0x72,0x1f,0x53,0x41,0xc6,0x53,0x41,0xc7,0x53,0x41,0xc6,0x53,0x41,0xa4,0xf8,0xc7,0x53,0x41,0x72,0x10,0x53,0x41,0x72,0x11,0x52,0xe5,0x72,0x10,0x52,0xe0,0xa6,0x0a,0x4a,0x72,0x01,0x52,0xe5,0xfb,0x72,0x11,0x52,0xe5,0x26,0xf4,0x72,0x11,0x52,0xe0,0x72,0x18,0x50,0xc4,0x72,0x1a,0x50,0xc3,0xc6,0x52,0x30,0xc6,0x52,0x31,0x72,0x5f,0x52,0x33,0x72,0x5f,0x52,0x32,0x72,0x5f,0x52,0x34,0x72,0x5f,0x52,0x35,0x72,0x5f,0x52,0x36,0x72,0x5f,0x52,0x37,0xc6,0x52,0x34,0xa4,0xe9,0xc7,0x52,0x34,0xc6,0x52,0x34,0xc7,0x52,0x34,0xc6,0x52,0x36,0xa4,0xcf,0xc7,0x52,0x36,0xc6,0x52,0x36,0xc7,0x52,0x36,0xc6,0x52,0x32,0x72,0x5f,0x52,0x32,0xc6,0x52,0x33,0xa4,0x0f,0xc7,0x52,0x33,0xc6,0x52,0x33,0xa4,0xf0,0xc7,0x52,0x33,0x5f,0xbf,0x02,0xbf,0x00,0xc6,0x50,0xc7,0xa1,0x01,0x27,0x0f,0xa1,0x02,0x26,0x07,0xae,0x94,0x70,0xbf,0x02,0x20,0x0e,0xa1,0x04,0x26,0x0a,0xae,0x24,0x00,0xbf,0x02,0xae,0x00,0xf4,0xbf,0x00,0xc6,0x50,0xc0,0xa4,0x07,0x5f,0x97,0xd6,0x80,0x94,0x97,0xbf,0x06,0x5f,0xbf,0x04,0x8d,0x00,0x84,0xf1,0x8d,0x00,0x84,0xed,0x00,0x0f,0x42,0x40,0xbe,0x02,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x9f,0xa4,0xf0,0xc7,0x52,0x33,0xb6,0x03,0xa4,0x0f,0xca,0x52,0x33,0xc7,0x52,0x33,0xbe,0x02,0x54,0x54,0x54,0x54,0x9f,0xc7,0x52,0x32,0xc6,0x52,0x35,0xa4,0xf3,0xc7,0x52,0x35,0xc6,0x52,0x35,0xaa,0x0c,0xc7,0x52,0x35,0x72,0x15,0x50,0x0e,0x72,0x15,0x50,0x0c,0x72,0x14,0x50,0x0d,0x72,0x15,0x50,0x0e,0x72,0x17,0x50,0x0e,0x72,0x16,0x50,0x0a,0x72,0x16,0x50,0x0c,0x72,0x16,0x50,0x0d,0x72,0x16,0x50,0x0e,0x72,0x1b,0x52,0x34,0x72,0x11,0x50,0x70,0x35,0xfc,0x50,0x70,0x72,0x11,0x50,0x7f,0x72,0x5f,0x50,0x7f,0x72,0x5f,0x50,0x81,0x35,0x52,0x50,0x82,0x72,0x5f,0x50,0x83,0x72,0x5f,0x50,0x85,0x72,0x5f,0x50,0x86,0x72,0x5f,0x50,0x80,0xc6,0x50,0x7f,0xaa,0x28,0xc7,0x50,0x7f,0xc6,0x50,0x80,0xaa,0x30,0xc7,0x50,0x80,0x35,0x52,0x50,0x82,0x35,0x31,0x50,0x83,0x72,0x5f,0x50,0x85,0xae,0x00,0x10,0x9f,0xc7,0x50,0x86,0x72,0x10,0x50,0x70,0x72,0x15,0x50,0xc3,0x72,0x17,0x50,0x09,0x72,0x16,0x50,0x05,0x72,0x16,0x50,0x07,0x72,0x16,0x50,0x08,0x72,0x16,0x50,0x05,0x20,0x53,0x72,0x0d,0x52,0x30,0xfb,0xce,0x00,0x16,0x9f,0xc7,0x00,0x10,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x9f,0xca,0x00,0x1c,0xc7,0x00,0x11,0x72,0x06,0x50,0x05,0x08,0xc6,0x00,0x11,0xaa,0x80,0xc7,0x00,0x11,0xce,0x00,0x18,0x9f,0xc7,0x00,0x12,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x9f,0xc7,0x00,0x13,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0x72,0x5f,0x00,0x1c,0xce,0x00,0x1a,0xa3,0x03,0xe9,0x24,0x05,0xce,0x00,0x1a,0x26,0x33,0x35,0x01,0x53,0x4b,0x72,0x12,0x53,0x40,0x72,0x01,0x53,0x43,0xfb,0xc6,0x53,0x44,0x5f,0x97,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0xcf,0x00,0x14,0xc6,0x53,0x45,0x90,0x5f,0x90,0x97,0x90,0xbf,0x00,0x01,0xba,0x01,0x02,0xcf,0x00,0x14,0x5f,0x5c,0xcf,0x00,0x1a,0xce,0x00,0x1a,0x5c,0xcf,0x00,0x1a,0x35,0x04,0x53,0x4b,0x72,0x12,0x53,0x40,0x72,0x01,0x53,0x43,0xfb,0xc6,0x53,0x44,0x5f,0x97,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0xcf,0x00,0x16,0xc6,0x53,0x45,0x90,0x5f,0x90,0x97,0x90,0xbf,0x00,0x01,0xba,0x01,0x02,0x72,0xb0,0x00,0x14,0xcf,0x00,0x16,0x35,0x02,0x53,0x4b,0x72,0x12,0x53,0x40,0x72,0x01,0x53,0x43,0xfb,0xc6,0x53,0x44,0x5f,0x97,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0xcf,0x00,0x18,0xc6,0x53,0x45,0x90,0x97,0x90,0xbf,0x00,0x01,0xba,0x01,0x02,0x72,0xb0,0x00,0x14,0xcf,0x00,0x18,0xc3,0x00,0x0c,0x2e,0x08,0xce,0x00,0x0e,0xc3,0x00,0x18,0x2f,0x08,0x72,0x16,0x50,0x05,0x35,0x40,0x00,0x1c,0xc6,0x52,0x30,0xa4,0x20,0xca,0x52,0x31,0xa1,0x21,0x26,0x03,0xcc,0x82,0xa3,0xa1,0x22,0x26,0x24,0x72,0x16,0x50,0x05,0x72,0x0d,0x52,0x30,0xfb,0x35,0xa5,0x00,0x10,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0xcc,0x82,0xf6,0xa1,0x23,0x26,0x24,0x72,0x17,0x50,0x05,0x72,0x0d,0x52,0x30,0xfb,0x35,0xa5,0x00,0x10,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0xcc,0x82,0xf6,0xa1,0x24,0x27,0x03,0xcc,0x84,0xae,0x72,0x0d,0x52,0x30,0xfb,0x35,0xa5,0x00,0x10,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0x72,0x0b,0x52,0x30,0xfb,0xc6,0x52,0x31,0x5f,0x97,0xcf,0x00,0x0c,0x72,0x0d,0x52,0x30,0xfb,0x35,0xa5,0x00,0x10,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0x72,0x0b,0x52,0x30,0xfb,0xc6,0x52,0x31,0x97,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x90,0xce,0x00,0x0c,0xbf,0x00,0x51,0x01,0xba,0x01,0x01,0xba,0x00,0x01,0x51,0x90,0xcf,0x00,0x0c,0x72,0x0d,0x52,0x30,0xfb,0x35,0xa5,0x00,0x10,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0x90,0xce,0x00,0x0c,0x93,0x50,0xcf,0x00,0x0e,0xcc,0x82,0xf6,0xa1,0x25,0x26,0x28,0x72,0x0d,0x52,0x30,0xfb,0x72,0x5f,0x00,0x10,0x35,0x01,0x00,0x11,0x72,0x5f,0x00,0x12,0x72,0x11,0x50,0x7f,0x35,0x04,0x50,0x81,0x72,0x1e,0x52,0x38,0x35,0xbf,0x52,0x30,0x72,0x10,0x50,0x7f,0xcc,0x82,0xf6,0xa1,0x7f,0x27,0x03,0xcc,0x82,0xf6,0xae,0x55,0xaa,0xcf,0x48,0x0b,0xcc,0x60,0x2d,0xcc,0x82,0xf6,0x8d,0x00,0x85,0x5e,0xbe,0x00,0x26,0x1e,0x90,0xbe,0x04,0x26,0x0c,0xbe,0x02,0x90,0xbe,0x06,0x65,0xbf,0x02,0x90,0xbf,0x06,0x87,0xbf,0x04,0x45,0x02,0x06,0x45,0x03,0x07,0xbf,0x00,0xbf,0x02,0x87,0xa6,0x20,0x3d,0x00,0x26,0x0d,0xbe,0x01,0xbf,0x00,0x45,0x03,0x02,0x3f,0x03,0x3a,0x03,0xa0,0x08,0x5f,0x90,0x5f,0x99,0x20,0x17,0x90,0x59,0x59,0xb3,0x04,0x26,0x03,0x90,0xb3,0x06,0x25,0x0b,0x72,0xb2,0x00,0x06,0x24,0x01,0x5a,0x72,0xb0,0x00,0x04,0x39,0x03,0x39,0x02,0x39,0x01,0x39,0x00,0x4a,0x2a,0xde,0xbf,0x04,0x90,0xbf,0x06,0xbe,0x00,0x53,0xbf,0x00,0xbe,0x02,0x53,0xbf,0x02,0x87,0x88,0x7b,0x05,0xb7,0x05,0x1e,0x06,0xbf,0x06,0x1c,0x00,0x04,0x1f,0x06,0x24,0x02,0x0c,0x05,0x5f,0x92,0xaf,0x00,0x05,0x88,0x5c,0xa3,0x00,0x04,0x26,0xf5,0x32,0x00,0x07,0x32,0x00,0x06,0x32,0x00,0x05,0x32,0x00,0x04,0x84,0x87,0x89,0xfe,0x90,0x93,0x85,0x5c,0x5c,0x90,0x5d,0x27,0x1c,0x89,0xfe,0xbf,0x00,0x85,0x5c,0x5c,0x89,0xfe,0xbf,0x02,0x85,0x5c,0x5c,0x51,0x5a,0x92,0xd6,0x00,0x92,0xd7,0x02,0x5a,0x2a,0xf7,0x51,0x20,0xd9,0x87,0x90,0xae,0x80,0x80,0x20,0x11,0x93,0x1c,0x00,0x03,0x89,0x93,0x8d,0x00,0x86,0x05,0x85,0x92,0x8d,0x00,0x05,0x90,0x93,0x90,0xa3,0x80,0x94,0x26,0xe9,0x87,0x89,0xfe,0x90,0x93,0x85,0x5c,0x5c,0x90,0x5d,0x27,0x12,0x89,0xfe,0xbf,0x00,0x85,0x5c,0x5c,0x51,0x5a,0x92,0x6f,0x00,0x5a,0x2a,0xfa,0x51,0x20,0xe3,0x87,0xae,0x07,0xff,0x94,0x8d,0x00,0x86,0x21,0x5d,0x27,0x04,0x8d,0x00,0x85,0xb2,0x8d,0x00,0x80,0x9d,0xac,0x00,0x86,0x1d,0x88,0xf6,0xb7,0x05,0xe6,0x01,0xb7,0x06,0xe6,0x02,0xb7,0x07,0x84,0x87,0x89,0x85,0x8d,0x00,0x86,0x27,0xac,0x00,0x86,0x24,0xac,0x00,0x86,0x13,0x5f,0x5c,0x87,0x9d,0x20,0xfd,0x20,0xfe
	};
#endif	
	
	uint32_t unOffset = 0x00000000;	
//#ifdef _JUST_DATA_KL17
	const uint8_t ucDataBuf[] = {
	0x00,0x60,0x00,0x20,0x71,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x83,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x3f,0xff,0xff,0x10,0xb5,0x06,0x4c,0x23,0x78,0x00,0x2b,0x07,0xd1,0x05,0x4b,0x00,0x2b,0x02,0xd0,0x04,0x48,0x00,0xe0,0x00,0xbf,0x01,0x23,0x23,0x70,0x10,0xbd,0x08,0xe5,0xff,0x1f,0x00,0x00,0x00,0x00,0x7c,0x10,0x00,0x00,0x08,0xb5,0x08,0x4b,0x00,0x2b,0x03,0xd0,0x07,0x48,0x08,0x49,0x00,0xe0,0x00,0xbf,0x07,0x48,0x03,0x68,0x00,0x2b,0x03,0xd0,0x06,0x4b,0x00,0x2b,0x00,0xd0,0x98,0x47,0x08,0xbd,0xc0,0x46,0x00,0x00,0x00,0x00,0x7c,0x10,0x00,0x00,0x0c,0xe5,0xff,0x1f,0x04,0xe5,0xff,0x1f,0x00,0x00,0x00,0x00,0x72,0xb6,0x00,0xf0,0x31,0xfd,0x00,0xf0,0x77,0xfd,0x00,0xf0,0xd9,0xfd,0x00,0xf0,0xa1,0xfc,0x01,0x48,0x00,0x47,0x00,0x00,0x83,0x04,0x00,0x00,0x00,0x29,0x34,0xd0,0x01,0x23,0x00,0x22,0x10,0xb4,0x88,0x42,0x2c,0xd3,0x01,0x24,0x24,0x07,0xa1,0x42,0x04,0xd2,0x81,0x42,0x02,0xd2,0x09,0x01,0x1b,0x01,0xf8,0xe7,0xe4,0x00,0xa1,0x42,0x04,0xd2,0x81,0x42,0x02,0xd2,0x49,0x00,0x5b,0x00,0xf8,0xe7,0x88,0x42,0x01,0xd3,0x40,0x1a,0x1a,0x43,0x4c,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0x5c,0x08,0x22,0x43,0x8c,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0x9c,0x08,0x22,0x43,0xcc,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0xdc,0x08,0x22,0x43,0x00,0x28,0x03,0xd0,0x1b,0x09,0x01,0xd0,0x09,0x09,0xe3,0xe7,0x10,0x1c,0x10,0xbc,0x70,0x47,0x00,0x28,0x01,0xd0,0x00,0x20,0xc0,0x43,0x07,0xb4,0x02,0x48,0x02,0xa1,0x40,0x18,0x02,0x90,0x03,0xbd,0xc0,0x46,0xd9,0x00,0x00,0x00,0x00,0x29,0xf0,0xd0,0x03,0xb5,0xff,0xf7,0xb9,0xff,0x0e,0xbc,0x42,0x43,0x89,0x1a,0x18,0x47,0xc0,0x46,0x00,0x29,0x41,0xd0,0x10,0xb4,0x04,0x1c,0x4c,0x40,0xa4,0x46,0x01,0x23,0x00,0x22,0x00,0x29,0x00,0xd5,0x49,0x42,0x00,0x28,0x00,0xd5,0x40,0x42,0x88,0x42,0x2c,0xd3,0x01,0x24,0x24,0x07,0xa1,0x42,0x04,0xd2,0x81,0x42,0x02,0xd2,0x09,0x01,0x1b,0x01,0xf8,0xe7,0xe4,0x00,0xa1,0x42,0x04,0xd2,0x81,0x42,0x02,0xd2,0x49,0x00,0x5b,0x00,0xf8,0xe7,0x88,0x42,0x01,0xd3,0x40,0x1a,0x1a,0x43,0x4c,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0x5c,0x08,0x22,0x43,0x8c,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0x9c,0x08,0x22,0x43,0xcc,0x08,0xa0,0x42,0x02,0xd3,0x00,0x1b,0xdc,0x08,0x22,0x43,0x00,0x28,0x03,0xd0,0x1b,0x09,0x01,0xd0,0x09,0x09,0xe3,0xe7,0x10,0x1c,0x64,0x46,0x00,0x2c,0x00,0xd5,0x40,0x42,0x10,0xbc,0x70,0x47,0x00,0x28,0x06,0xd0,0x03,0xdb,0x00,0x20,0xc0,0x43,0x40,0x08,0x01,0xe0,0x80,0x20,0x00,0x06,0x07,0xb4,0x02,0x48,0x02,0xa1,0x40,0x18,0x02,0x90,0x03,0xbd,0xc0,0x46,0x19,0x00,0x00,0x00,0x00,0x29,0xeb,0xd0,0x03,0xb5,0xff,0xf7,0xa7,0xff,0x0e,0xbc,0x42,0x43,0x89,0x1a,0x18,0x47,0xc0,0x46,0x70,0x47,0xc0,0x46,0x80,0xb5,0x00,0xaf,0x0a,0x4b,0x02,0x22,0x1a,0x81,0x09,0x4b,0x00,0x22,0x5a,0x81,0x08,0x4b,0x80,0x22,0x52,0x04,0x1a,0x60,0x06,0x4b,0x03,0x22,0x1a,0x60,0x06,0x4b,0x06,0x4a,0x1a,0x60,0x06,0x4b,0x07,0x4a,0x1a,0x60,0xbd,0x46,0x80,0xbd,0xc0,0x46,0x24,0xe5,0xff,0x1f,0x08,0x81,0x00,0x40,0x00,0x81,0x00,0x40,0x2c,0xe5,0xff,0x1f,0x0c,0x81,0x00,0x40,0x80,0x00,0x52,0x60,0x80,0xb5,0x00,0xaf,0x13,0x4b,0x1b,0x68,0x00,0x2b,0x08,0xd1,0x12,0x4b,0x9b,0x88,0x9b,0xb2,0x01,0x22,0x13,0x43,0x9a,0xb2,0x0f,0x4b,0x9a,0x80,0x07,0xe0,0x0e,0x4b,0x9b,0x88,0x9b,0xb2,0x01,0x22,0x93,0x43,0x9a,0xb2,0x0b,0x4b,0x9a,0x80,0x0b,0x4b,0x80,0x22,0x52,0x04,0x1a,0x60,0x09,0x4b,0x05,0x22,0x1a,0x60,0x08,0x4b,0x09,0x4a,0x1a,0x60,0x09,0x4b,0x04,0x4a,0x1a,0x60,0x08,0x4b,0x09,0x4a,0x1a,0x60,0xbd,0x46,0x80,0xbd,0xc0,0x46,0x80,0xf0,0x0f,0x40,0x24,0xe5,0xff,0x1f,0x08,0x81,0x00,0x40,0x04,0x81,0x00,0x40,0x0c,0x40,0x05,0x40,0x00,0x81,0x00,0x40,0x0c,0x81,0x00,0x40,0x80,0x00,0x52,0x60,0x80,0xb5,0x82,0xb0,0x00,0xaf,0x02,0x1c,0xfb,0x1d,0x1a,0x70,0x06,0x4b,0xfa,0x1d,0x12,0x78,0x11,0x1c,0x1f,0x22,0x0a,0x40,0x01,0x21,0x08,0x1c,0x90,0x40,0x02,0x1c,0x1a,0x60,0xbd,0x46,0x02,0xb0,0x80,0xbd,0x00,0xe1,0x00,0xe0,0x80,0xb5,0x82,0xb0,0x00,0xaf,0x02,0x1c,0xfb,0x1d,0x1a,0x70,0x07,0x4a,0xfb,0x1d,0x1b,0x78,0x19,0x1c,0x1f,0x23,0x0b,0x40,0x01,0x21,0x08,0x1c,0x98,0x40,0x03,0x1c,0x19,0x1c,0x80,0x23,0xd1,0x50,0xbd,0x46,0x02,0xb0,0x80,0xbd,0x00,0xe1,0x00,0xe0,0x80,0xb5,0x82,0xb0,0x00,0xaf,0x02,0x1c,0xfb,0x1d,0x1a,0x70,0x08,0x4a,0xfb,0x1d,0x1b,0x78,0x19,0x1c,0x1f,0x23,0x0b,0x40,0x01,0x21,0x08,0x1c,0x98,0x40,0x03,0x1c,0x19,0x1c,0xc0,0x23,0x5b,0x00,0xd1,0x50,0xbd,0x46,0x02,0xb0,0x80,0xbd,0xc0,0x46,0x00,0xe1,0x00,0xe0,0x80,0xb5,0x82,0xb0,0x00,0xaf,0x40,0x4b,0x80,0x22,0x52,0x04,0x1a,0x60,0x3e,0x4b,0x01,0x22,0x1a,0x60,0x3d,0x4b,0x1b,0x78,0xdb,0xb2,0x01,0x2b,0x09,0xd1,0x3c,0x4b,0x1b,0x78,0xdb,0xb2,0x1a,0x1c,0x3b,0x4b,0x1a,0x80,0x38,0x4b,0x02,0x22,0x1a,0x70,0x64,0xe0,0x36,0x4b,0x1b,0x78,0xdb,0xb2,0x02,0x2b,0x18,0xd1,0x34,0x4b,0x1b,0x78,0xdb,0xb2,0x1b,0x02,0x9a,0xb2,0x33,0x4b,0x1b,0x88,0x9b,0xb2,0x13,0x43,0x9a,0xb2,0x30,0x4b,0x1a,0x80,0x2f,0x4b,0x1b,0x88,0x9b,0xb2,0x9b,0xb2,0x5b,0x42,0x9b,0xb2,0x9a,0xb2,0x2d,0x4b,0x1a,0x80,0x29,0x4b,0x00,0x22,0x1a,0x70,0x46,0xe0,0x28,0x4b,0x1b,0x78,0xdb,0xb2,0x01,0x2b,0x02,0xd1,0xff,0xf7,0x40,0xff,0x3e,0xe0,0x24,0x4b,0x1b,0x78,0xdb,0xb2,0x02,0x2b,0x06,0xd1,0x24,0x4b,0x10,0x22,0x5a,0x60,0x24,0x4b,0x00,0x22,0x1a,0x80,0x32,0xe0,0x1e,0x4b,0x1b,0x78,0xdb,0xb2,0x03,0x2b,0x06,0xd1,0x1e,0x4b,0x10,0x22,0x9a,0x60,0x1e,0x4b,0x00,0x22,0x1a,0x80,0x26,0xe0,0x18,0x4b,0x1b,0x78,0xdb,0xb2,0x04,0x2b,0x03,0xd1,0x14,0x4b,0x01,0x22,0x1a,0x70,0x1d,0xe0,0x13,0x4b,0x1b,0x78,0xdb,0xb2,0x05,0x2b,0x02,0xd1,0xff,0xf7,0xf3,0xfe,0x15,0xe0,0x0f,0x4b,0x1b,0x78,0xdb,0xb2,0x7f,0x2b,0x10,0xd1,0x12,0x4b,0x11,0x4a,0x92,0x79,0xd2,0xb2,0x06,0x21,0x0a,0x43,0xd2,0xb2,0x9a,0x71,0x0f,0x4b,0x1b,0x68,0x1b,0x68,0x7b,0x60,0x7b,0x68,0x3b,0x60,0x3b,0x68,0x00,0x20,0x98,0x47,0x0b,0x4b,0x0c,0x4a,0x1a,0x60,0xbd,0x46,0x02,0xb0,0x80,0xbd,0x38,0x81,0x00,0x40,0x4a,0xe5,0xff,0x1f,0x44,0xe5,0xff,0x1f,0x00,0xe5,0xff,0x1f,0x02,0xe5,0xff,0x1f,0x80,0xf0,0x0f,0x40,0x48,0xe5,0xff,0x1f,0x00,0xf0,0x07,0x40,0x1c,0x00,0x00,0x1c,0x3c,0x81,0x00,0x40,0x00,0x00,0x92,0xe0,0x80,0xb5,0x00,0xaf,0x0c,0x4b,0x80,0x22,0x52,0x04,0x1a,0x60,0x0a,0x4b,0x02,0x22,0x1a,0x60,0x0a,0x4b,0x0a,0x4a,0x12,0x68,0x1a,0x60,0x0a,0x4b,0x0a,0x4a,0x1a,0x60,0x0a,0x4b,0x0b,0x22,0x1a,0x60,0x0a,0x4b,0x01,0x22,0x1a,0x80,0x09,0x4b,0x01,0x22,0x1a,0x70,0xbd,0x46,0x80,0xbd,0xc0,0x46,0x28,0x81,0x00,0x40,0x20,0x81,0x00,0x40,0x10,0xb0,0x03,0x40,0x2c,0x81,0x00,0x40,0x80,0x00,0xa4,0xc0,0x00,0xb0,0x03,0x40,0x4c,0xe5,0xff,0x1f,0x4b,0xe5,0xff,0x1f,0x80,0xb5,0x00,0xaf,0x03,0x4a,0x04,0x4b,0x9a,0x64,0x04,0x4a,0x02,0x4b,0xda,0x64,0xbd,0x46,0x80,0xbd,0x6d,0x08,0x00,0x00,0x00,0xe0,0xff,0x1f,0x39,0x07,0x00,0x00,0x80,0xb5,0x00,0xaf,0x49,0x4b,0x49,0x4a,0x11,0x68,0x49,0x4a,0x0a,0x40,0xc0,0x21,0x09,0x03,0x0a,0x43,0x1a,0x60,0x45,0x4a,0x44,0x49,0x46,0x4b,0xc9,0x58,0x46,0x4b,0x0b,0x40,0x46,0x49,0x19,0x43,0x43,0x4b,0xd1,0x50,0x40,0x4a,0x3f,0x49,0x44,0x4b,0xc9,0x58,0x44,0x4b,0x0b,0x40,0x80,0x21,0x49,0x02,0x19,0x43,0x40,0x4b,0xd1,0x50,0x3a,0x4a,0x3a,0x49,0x40,0x4b,0xc9,0x58,0x40,0x4b,0x19,0x40,0x3e,0x4b,0xd1,0x50,0x36,0x4a,0x36,0x49,0x3e,0x4b,0xc9,0x58,0x3e,0x4b,0x19,0x40,0x3c,0x4b,0xd1,0x50,0x32,0x4a,0x32,0x49,0x3c,0x4b,0xcb,0x58,0x03,0x21,0x18,0x1c,0x88,0x43,0x01,0x1c,0x39,0x4b,0xd1,0x50,0x2d,0x4a,0x2d,0x49,0x38,0x4b,0xcb,0x58,0x9f,0x21,0x18,0x1c,0x88,0x43,0x01,0x1c,0x35,0x4b,0xd1,0x50,0x28,0x4a,0x28,0x49,0x34,0x4b,0xc9,0x58,0x34,0x4b,0x19,0x40,0x32,0x4b,0xd1,0x50,0x24,0x4a,0x24,0x49,0x32,0x4b,0xc9,0x58,0x32,0x4b,0x19,0x40,0x30,0x4b,0xd1,0x50,0x20,0x4a,0x20,0x49,0x30,0x4b,0xc9,0x58,0x30,0x4b,0x0b,0x40,0x01,0x21,0x19,0x43,0x2d,0x4b,0xd1,0x50,0x1b,0x4a,0x1b,0x49,0x82,0x23,0x5b,0x01,0xcb,0x58,0x80,0x21,0x49,0x00,0x19,0x43,0x82,0x23,0x5b,0x01,0xd1,0x50,0x16,0x4a,0x15,0x49,0x88,0x23,0x5b,0x01,0xcb,0x58,0xff,0x21,0x18,0x1c,0x88,0x43,0x01,0x1c,0x88,0x23,0x5b,0x01,0xd1,0x50,0x23,0x4b,0x80,0x22,0xd2,0x04,0x1a,0x60,0x22,0x4b,0x80,0x22,0x92,0x00,0x1a,0x60,0x21,0x4b,0x80,0x22,0xd2,0x00,0x1a,0x60,0x20,0x4b,0x80,0x22,0x12,0x01,0x1a,0x60,0x1f,0x4b,0x02,0x22,0x1a,0x60,0x1e,0x4b,0x80,0x22,0x52,0x00,0x1a,0x60,0x1d,0x4b,0x80,0x22,0x12,0x05,0x1a,0x60,0x1c,0x4b,0x80,0x22,0x52,0x03,0x1a,0x60,0xbd,0x46,0x80,0xbd,0x00,0x70,0x04,0x40,0xff,0xff,0xf0,0xff,0x04,0x10,0x00,0x00,0x0f,0xff,0x3f,0xc0,0x40,0x00,0x00,0x0c,0x44,0x10,0x00,0x00,0xff,0xff,0xf8,0x0f,0x0c,0x10,0x00,0x00,0xff,0xff,0xeb,0xf8,0x10,0x10,0x00,0x00,0x88,0xff,0xf8,0xff,0x4c,0x10,0x00,0x00,0x18,0x10,0x00,0x00,0x34,0x10,0x00,0x00,0x3f,0xef,0x27,0xff,0x38,0x10,0x00,0x00,0xfe,0xc1,0xcf,0x7f,0x3c,0x10,0x00,0x00,0xfc,0x7f,0x7f,0x50,0x04,0x80,0x0c,0x5d,0x38,0x80,0x84,0x54,0x38,0x80,0x04,0x55,0x38,0x80,0x84,0x55,0x3c,0x80,0x84,0x50,0x40,0x80,0x04,0x54,0x3c,0x80,0x84,0x5d,0x38,0x80,0x04,0x5a,0x80,0xb5,0x00,0xaf,0x16,0x4b,0xe0,0x22,0xd2,0x00,0x1a,0x60,0x15,0x4b,0xe0,0x22,0xd2,0x00,0x1a,0x60,0x14,0x4b,0x80,0x22,0x52,0x00,0x1a,0x60,0x13,0x4b,0x10,0x22,0x1a,0x60,0x13,0x4b,0x10,0x22,0x5a,0x60,0x12,0x4b,0x00,0x22,0x1a,0x60,0x12,0x4b,0x00,0x22,0x1a,0x60,0x11,0x4b,0x00,0x22,0x1a,0x60,0x11,0x4b,0x80,0x22,0x92,0x00,0x1a,0x60,0x10,0x4b,0x80,0x22,0x92,0x00,0x1a,0x60,0x0f,0x4b,0x01,0x22,0x1a,0x60,0x0e,0x4b,0x02,0x22,0x1a,0x60,0x0e,0x4b,0x00,0x22,0x1a,0x60,0xbd,0x46,0x80,0xbd,0x00,0x90,0x14,0x54,0x0c,0x90,0x14,0x54,0x10,0xb0,0x14,0x54,0x94,0xf0,0x0f,0x48,0x80,0xf0,0x0f,0x40,0x00,0xa0,0x14,0x54,0x04,0xb0,0x14,0x54,0x08,0xb0,0x14,0x54,0x04,0x90,0x14,0x54,0x08,0x90,0x14,0x54,0x08,0x90,0x04,0x50,0x08,0x90,0x84,0x50,0x10,0x80,0x04,0x51,0x80,0xb5,0x00,0xaf,0x0e,0x4b,0x00,0x22,0x1a,0x70,0x0e,0x4b,0x00,0x22,0x1a,0x70,0x0d,0x4b,0x00,0x22,0x1a,0x70,0x0d,0x4b,0x00,0x22,0x1a,0x70,0x0c,0x4b,0x03,0x22,0x1a,0x70,0x07,0x4b,0x80,0x22,0x1a,0x70,0x0a,0x4b,0x02,0x22,0x1a,0x70,0x07,0x4b,0x80,0x22,0x1a,0x70,0x03,0x20,0xff,0xf7,0xaf,0xfd,0xbd,0x46,0x80,0xbd,0xc0,0x46,0x00,0x10,0x82,0x53,0x01,0x10,0x82,0x53,0x02,0x10,0x82,0x53,0x03,0x10,0x82,0x53,0x00,0x10,0x2a,0x50,0x03,0x10,0x2a,0x50,0x80,0xb5,0x00,0xaf,0x0e,0x4b,0x00,0x22,0x9a,0x60,0x0d,0x4b,0x00,0x22,0xda,0x60,0x0b,0x4b,0x00,0x22,0x9a,0x61,0x0a,0x4b,0x00,0x22,0xda,0x61,0x08,0x4b,0x00,0x22,0x1a,0x62,0x07,0x4b,0x00,0x22,0x5a,0x62,0x05,0x4b,0x07,0x22,0x9a,0x60,0x04,0x4b,0x0b,0x22,0xda,0x60,0x02,0x4b,0x00,0x22,0x1a,0x62,0xbd,0x46,0x80,0xbd,0xc0,0x46,0x00,0xb0,0x03,0x40,0x80,0xb5,0x86,0xb0,0x00,0xaf,0x6e,0x4b,0x6e,0x4a,0x1a,0x60,0x6c,0x4b,0x6e,0x4a,0x5a,0x60,0x6b,0x4b,0x00,0x22,0x9a,0x60,0x69,0x4b,0x00,0x22,0x1a,0x61,0x04,0x23,0xfb,0x60,0xfb,0x68,0x69,0x4a,0x53,0x43,0x69,0x48,0x19,0x1c,0xff,0xf7,0x58,0xfc,0x03,0x1c,0x1a,0x1c,0x3b,0x1c,0x0a,0x33,0x1a,0x80,0x3b,0x1c,0x0a,0x33,0x1b,0x88,0xfa,0x68,0x53,0x43,0x62,0x48,0x19,0x1c,0xff,0xf7,0x4a,0xfc,0x03,0x1c,0x7b,0x60,0x7a,0x68,0x5e,0x4b,0x9a,0x42,0x04,0xd9,0x7b,0x68,0x5e,0x4a,0x9b,0x18,0x3b,0x61,0x03,0xe0,0x7b,0x68,0x59,0x4a,0xd3,0x1a,0x3b,0x61,0x3b,0x1c,0x08,0x33,0x05,0x22,0x1a,0x80,0x3b,0xe0,0x3b,0x1c,0x08,0x33,0x1b,0x88,0x54,0x4a,0x53,0x43,0x54,0x48,0x19,0x1c,0xff,0xf7,0x2d,0xfc,0x03,0x1c,0x1a,0x1c,0xbb,0x1c,0x1a,0x80,0x3b,0x1c,0x08,0x33,0x1b,0x88,0xba,0x1c,0x12,0x88,0x53,0x43,0x4d,0x48,0x19,0x1c,0xff,0xf7,0x6d,0xfc,0x03,0x1c,0x7b,0x60,0x7a,0x68,0x48,0x4b,0x9a,0x42,0x04,0xd9,0x7b,0x68,0x48,0x4a,0x9b,0x18,0x7b,0x61,0x03,0xe0,0x7b,0x68,0x44,0x4a,0xd3,0x1a,0x7b,0x61,0x7a,0x69,0x3b,0x69,0x9a,0x42,0x0a,0xd8,0x7b,0x69,0x3b,0x61,0x3b,0x1c,0x08,0x33,0x1b,0x88,0xfb,0x60,0x3b,0x1c,0x0a,0x33,0xba,0x1c,0x12,0x88,0x1a,0x80,0x3b,0x1c,0x08,0x33,0x1a,0x88,0x3b,0x1c,0x08,0x33,0x01,0x32,0x1a,0x80,0x3b,0x1c,0x08,0x33,0x1b,0x88,0x20,0x2b,0xbe,0xd9,0x3a,0x69,0x37,0x4b,0x9a,0x42,0x13,0xd8,0xfb,0x68,0x03,0x2b,0x06,0xd9,0xfb,0x68,0x07,0x2b,0x03,0xd8,0x34,0x4b,0x80,0x22,0x92,0x02,0x1a,0x60,0x33,0x4b,0xfa,0x68,0x01,0x3a,0x12,0x06,0x1a,0x60,0x31,0x4b,0x3a,0x1c,0x0a,0x32,0x12,0x88,0x1a,0x60,0x30,0x4b,0x00,0x22,0x1a,0x60,0x2f,0x4b,0x00,0x22,0x1a,0x60,0x2f,0x4b,0x00,0x22,0x1a,0x60,0x2e,0x4b,0x00,0x22,0x1a,0x60,0x2e,0x4b,0x00,0x22,0x1a,0x60,0x1e,0x4b,0x1e,0x4a,0x12,0x68,0x80,0x21,0x09,0x04,0x0a,0x43,0x1a,0x60,0x1b,0x4b,0x1a,0x4a,0x12,0x68,0x80,0x21,0x89,0x03,0x0a,0x43,0x1a,0x60,0x26,0x4b,0x80,0x22,0x12,0x03,0x1a,0x60,0x25,0x4b,0x80,0x22,0xd2,0x02,0x1a,0x60,0x24,0x4a,0x82,0x23,0x5b,0x00,0x24,0x49,0xd1,0x50,0x22,0x4a,0x98,0x23,0x5b,0x00,0x21,0x49,0xd1,0x50,0x1f,0x4a,0x21,0x49,0x9a,0x23,0x5b,0x00,0xd1,0x50,0x1d,0x4a,0x1c,0x49,0x9c,0x23,0x5b,0x00,0xcb,0x58,0x5b,0x0e,0x5b,0x06,0x01,0x21,0x19,0x43,0x9c,0x23,0x5b,0x00,0xd1,0x50,0x17,0x4a,0x9e,0x23,0x5b,0x00,0x18,0x49,0xd1,0x50,0x18,0x4b,0x80,0x22,0xd2,0x05,0x1a,0x60,0xbd,0x46,0x06,0xb0,0x80,0xbd,0xc0,0x46,0x00,0x40,0x05,0x40,0x04,0x00,0x00,0x0f,0x00,0xc0,0x1f,0xc0,0x00,0x1b,0xb7,0x00,0x00,0x6c,0xdc,0x02,0x00,0xe5,0x48,0xff,0x3f,0x7e,0x05,0x00,0x00,0x40,0x85,0x58,0x00,0x40,0x25,0x5c,0x00,0x40,0x65,0x50,0x08,0x40,0x05,0x52,0x00,0x40,0x85,0x5e,0x08,0x40,0x85,0x50,0x08,0x40,0x05,0x50,0x00,0x40,0x85,0x56,0x08,0x40,0x85,0x59,0x08,0x40,0x05,0x59,0x00,0x80,0x00,0x40,0x0c,0x40,0x05,0x40,0x44,0xe5,0xff,0x1f,0x00,0x00,0x92,0xa0,0x3c,0x81,0x00,0x5f,0x80,0xb5,0x82,0xb0,0x00,0xaf,0xfb,0x1d,0x00,0x22,0x1a,0x70,0x10,0xe0,0xfb,0x1d,0x1b,0x78,0x5b,0xb2,0x18,0x1c,0xff,0xf7,0x7b,0xfc,0xfb,0x1d,0x1b,0x78,0x5b,0xb2,0x18,0x1c,0xff,0xf7,0x8d,0xfc,0xfb,0x1d,0x1a,0x78,0xfb,0x1d,0x01,0x32,0x1a,0x70,0xfb,0x1d,0x1b,0x78,0x1e,0x2b,0xea,0xd9,0xff,0xf7,0x62,0xfd,0xff,0xf7,0x70,0xfd,0xff,0xf7,0x3a,0xfe,0x62,0xb6,0xff,0xf7,0x81,0xfe,0xff,0xf7,0xab,0xfe,0xff,0xf7,0xcb,0xfe,0xfb,0x1d,0x00,0x22,0x1a,0x70,0x0a,0xe0,0xfb,0x1d,0x1b,0x78,0x5b,0xb2,0x18,0x1c,0xff,0xf7,0x6d,0xfc,0xfb,0x1d,0x1a,0x78,0xfb,0x1d,0x01,0x32,0x1a,0x70,0xfb,0x1d,0x1b,0x78,0x1e,0x2b,0xf0,0xd9,0x22,0x4b,0x08,0x22,0x1a,0x60,0x21,0x4b,0x1a,0x68,0x80,0x23,0x13,0x40,0x3b,0xd0,0x1f,0x4b,0x1b,0x88,0x9b,0xb2,0x00,0x2b,0x12,0xd1,0x1c,0x4b,0x1b,0x69,0x9a,0xb2,0x1c,0x4b,0x1b,0x88,0x9b,0xb2,0x9b,0xb2,0xd3,0x1a,0x9b,0xb2,0x9a,0xb2,0x1a,0x4b,0x1a,0x80,0x16,0x4b,0x0f,0x22,0x1a,0x60,0x15,0x4b,0x01,0x22,0x1a,0x80,0x23,0xe0,0x13,0x4b,0x1b,0x88,0x9b,0xb2,0x01,0x2b,0x12,0xd1,0x10,0x4b,0x1b,0x69,0x9a,0xb2,0x10,0x4b,0x1b,0x88,0x9b,0xb2,0x9b,0xb2,0xd3,0x1a,0x9b,0xb2,0x9a,0xb2,0x0e,0x4b,0x5a,0x80,0x0a,0x4b,0x0b,0x22,0x1a,0x60,0x09,0x4b,0x02,0x22,0x1a,0x80,0x0b,0xe0,0x06,0x4b,0x1b,0x69,0x9a,0xb2,0x07,0x4b,0x1a,0x80,0x04,0x4b,0x08,0x22,0x1a,0x60,0x03,0x4b,0x00,0x22,0x1a,0x80,0xbe,0xe7,0xbd,0xe7,0xc0,0x46,0x00,0xb0,0x03,0x40,0x4c,0xe5,0xff,0x1f,0x46,0xe5,0xff,0x1f,0x24,0xe5,0xff,0x1f,0x80,0xb5,0x00,0xaf,0x1b,0x4a,0x88,0x23,0x5b,0x01,0x00,0x21,0xd1,0x50,0x1a,0x4b,0x22,0x22,0x1a,0x70,0x17,0x4a,0x19,0x4b,0x80,0x21,0x49,0x02,0xd1,0x50,0x15,0x4b,0x14,0x4a,0x12,0x68,0xc0,0x21,0x09,0x03,0x0a,0x43,0x1a,0x60,0x11,0x4a,0x11,0x49,0x13,0x4b,0xc9,0x58,0x13,0x4b,0x0b,0x40,0xc0,0x21,0x09,0x05,0x19,0x43,0x10,0x4b,0xd1,0x50,0x11,0x4b,0x0e,0x22,0x1a,0x72,0x0f,0x4b,0x87,0x22,0x1a,0x76,0x0e,0x4b,0x00,0x22,0x1a,0x70,0x0c,0x4b,0x00,0x22,0x5a,0x70,0x0c,0x4b,0x00,0x22,0x1a,0x70,0xc0,0x46,0x09,0x4b,0x9b,0x79,0xdb,0xb2,0x1a,0x1c,0x0c,0x23,0x13,0x40,0xf8,0xd1,0xbd,0x46,0x80,0xbd,0x00,0x70,0x04,0x40,0x00,0xe0,0x07,0x40,0x44,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0xff,0xff,0xff,0xc0,0x00,0x40,0x06,0x40,0x00,0x50,0x06,0x40,0x80,0xb5,0x88,0xb0,0x00,0xaf,0x27,0x4b,0xfb,0x60,0x27,0x4a,0x27,0x4b,0x9a,0x42,0x16,0xd0,0x00,0x23,0xfb,0x61,0x0a,0xe0,0x24,0x4b,0xfa,0x69,0x92,0x00,0xd1,0x58,0x21,0x4b,0xfa,0x69,0x92,0x00,0xd1,0x50,0xfb,0x69,0x01,0x33,0xfb,0x61,0xfb,0x68,0x9a,0x08,0xfb,0x69,0x9a,0x42,0xef,0xd8,0x1d,0x4b,0x1b,0x4a,0x9a,0x60,0x02,0xe0,0x1b,0x4b,0x1a,0x4a,0x9a,0x60,0x1b,0x4b,0xbb,0x61,0x1b,0x4b,0x7b,0x61,0x1b,0x4b,0xbb,0x60,0xba,0x68,0x7b,0x69,0xd3,0x1a,0xfb,0x61,0x07,0xe0,0xbb,0x69,0x5a,0x1c,0xba,0x61,0x7a,0x69,0x51,0x1c,0x79,0x61,0x12,0x78,0x1a,0x70,0xfb,0x69,0x5a,0x1e,0xfa,0x61,0x00,0x2b,0xf2,0xd1,0x12,0x4b,0x3b,0x61,0x12,0x4b,0x7b,0x60,0x7a,0x68,0x3b,0x69,0xd3,0x1a,0xfb,0x61,0x04,0xe0,0x3b,0x69,0x5a,0x1c,0x3a,0x61,0x00,0x22,0x1a,0x70,0xfb,0x69,0x5a,0x1e,0xfa,0x61,0x00,0x2b,0xf5,0xd1,0xbd,0x46,0x08,0xb0,0x80,0xbd,0xc0,0x46,0x00,0x02,0x00,0x00,0x00,0xe0,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0xed,0x00,0xe0,0x00,0xe5,0xff,0x1f,0x9c,0x10,0x00,0x00,0xa4,0x10,0x00,0x00,0x08,0xe5,0xff,0x1f,0x50,0xe5,0xff,0x1f,0x70,0xb5,0x0e,0x4b,0x0e,0x4d,0x00,0x24,0xed,0x1a,0xad,0x10,0x1e,0x1c,0xac,0x42,0x04,0xd0,0xa3,0x00,0xf3,0x58,0x98,0x47,0x01,0x34,0xf8,0xe7,0x00,0xf0,0x16,0xf8,0x08,0x4b,0x09,0x4d,0x00,0x24,0xed,0x1a,0xad,0x10,0x1e,0x1c,0xac,0x42,0x04,0xd0,0xa3,0x00,0xf3,0x58,0x98,0x47,0x01,0x34,0xf8,0xe7,0x70,0xbd,0x94,0x10,0x00,0x00,0x94,0x10,0x00,0x00,0x94,0x10,0x00,0x00,0x98,0x10,0x00,0x00,0xf8,0xb5,0xc0,0x46,0xf8,0xbc,0x08,0xbc,0x9e,0x46,0x70,0x47,0xf8,0xb5,0xc0,0x46,0xf8,0xbc,0x08,0xbc,0x9e,0x46,0x70,0x47,0x39,0x04,0x00,0x00,0x11,0x04,0x00,0x00,0xff,0x7f,0x00,0x80,0x00,0x00,0x00,0x00
	};
//#endif
	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
	
	if (argc >= 3)
		ucChannel = (uint8_t)simple_strtoul (argv[2], NULL, 10);

	if(ucTargetModuleSlot >= 0)
	{						
		/* Make SERDES request to write the specified "chunk" of data */ 	
		nStatus = nai_write_micro_request(ucRequesterID, ucTargetModuleSlot, ucChannel, unOffset, (uint8_t*)&ucDataBuf[0], sizeof(ucDataBuf));
		if (nStatus != NAI_SUCCESS)
			printf("Failed DT Config on Slot %d Channel %d - Status = %d\r\n", ucTargetModuleSlot, ucChannel, nStatus);
	} 
	else 
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot);
	
//#endif	
	return 0;
}


int do_naitestdtgetbyslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
//#ifdef CONFIG_NAI_MODULE_SUPPORT	
	uint8_t ucRequesterID = MB_SLOT;
	uint8_t ucTargetModuleSlot = 1;	
	uint32_t nStatus = NAI_MODULE_SUCCESS;	
	uint8_t ucDataBuf[50];
	uint8_t ucChannel = 1;
	uint16_t i = 0;
	
	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);
		
	if (argc >= 3)
		ucChannel = (uint8_t)simple_strtoul (argv[2], NULL, 10);

	memset(&ucDataBuf[0], 0, sizeof(ucDataBuf));
	
	if(ucTargetModuleSlot >= 0)
	{						
		/* Make SERDES request to write the specified "chunk" of data */ 				
		nStatus = nai_get_micro_request(ucRequesterID, ucTargetModuleSlot, ucChannel, &ucDataBuf[0], sizeof(ucDataBuf));

		if (nStatus != NAI_SUCCESS)
			printf("Failed DT Get on Slot %d Channel %d - Status = %d\r\n", ucTargetModuleSlot, ucChannel, nStatus);
		else
		{
			for (i = 0; i < sizeof(ucDataBuf); i++)
				printf("ucDataBuf[%u] = 0x%x\r\n", i, ucDataBuf[i]);
		}
	} 
	else 
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot);	
	
	return 0;
}

int do_naitestdterasebyslot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	uint8_t ucRequesterID = MB_SLOT;
	uint8_t ucTargetModuleSlot = 1;	
	uint32_t nStatus = NAI_MODULE_SUCCESS;	
	uint8_t ucChannel = 1;
	 
	if (argc >= 2)
		ucTargetModuleSlot = (uint8_t)simple_strtoul (argv[1], NULL, 16);

	if (argc >= 3)
		ucChannel = (uint8_t)simple_strtoul (argv[2], NULL, 10);
		
	if(ucTargetModuleSlot >= 0)
	{						
		/* Make SERDES request to erase every Microcontroller (16 on DT2) EEPROM */ 
		nStatus = nai_erase_micro_request(ucRequesterID, ucTargetModuleSlot, ucChannel);

		if (nStatus != NAI_SUCCESS)
			printf("Failed erase of Microcontroller on Slot %d Channel %d - Status = %d\r\n", ucTargetModuleSlot, ucChannel, nStatus);
	} 
	else 
		printf("Invalid SlotID 0x%x \r\n", ucTargetModuleSlot);
		
	return 0;	
}

/***************************************************/

#ifndef _BAREMETAL_
U_BOOT_CMD(
	naiforcemoduleslot,	2,	1,	do_naiforcemoduleslot,
	"naiforcemodule slot utility command",
	"[force module slot number to be used]"
);

U_BOOT_CMD(
	naimoduleprobe,	1,	1,	do_naimoduleprobe,
	"naimoduleprobe utility command",
	""
);

U_BOOT_CMD(
	naisend,	4,	1,	do_naisend,
	"naisend utility command",
	"[module slot number]"	
);

U_BOOT_CMD(
	naiwritereg32, 3, 1, do_naiwritereg32,
	"naiwritereg utility command",
	"[address(32bit HEX)] [value(32bit HEX)]"
);

U_BOOT_CMD(
	naiwritereg32byslot, 4, 1, do_naiwritereg32byslot,
	"naiwritereg utility command",
	"[slot id(8bit)] [module offset(32bit HEX)] [value(32bit HEX)]"
);

U_BOOT_CMD(
	naireadreg32, 2, 1, do_naireadreg32,
	"naireadreg utility command",
	"[address(32bit HEX)]"
);

U_BOOT_CMD(
	naireadreg32byslot, 3, 1, do_naireadreg32byslot,
	"naireadreg utility command",
	"[slot id(8bit HEX)] [module offset(32bitHEX)]"
);

U_BOOT_CMD(
	naiwritereg16, 3, 1, do_naiwritereg16,
	"naiwritereg utility command",
	"[address(32bit HEX)] [value(16bit HEX)]"
);

U_BOOT_CMD(
	naireadreg16, 2, 1, do_naireadreg16,
	"naireadreg utility command",
	"[address(32bit HEX)]"
);

U_BOOT_CMD(
	naiwriteblock32, 255, 1, do_naiwriteblock32,
	"naiwriteblock utility command",
	"[start_address(32bit)] [Stride(MAX 255)] [Count] [Data1(32Bit) Data2(32Bit) ... DataN(32Bit)]"
);

U_BOOT_CMD(
	naiwriteblock32byslot, 255, 1, do_naiwriteblock32byslot,
	"naiwriteblock utility command",
	"[slot id] [module offset start(32bit)] [Stride(MAX 255)] [Count] [Data1(32Bit) Data2(32Bit) ... DataN(32Bit)]"
);

U_BOOT_CMD(
	naireadblock32, 1024, 1, do_naireadblock32,
	"naireadblock utility command",
	"[start_address(32bit)] [Stride(MAX 1024)] [Count] [DataBuffer(32Bit)]"
);

U_BOOT_CMD(
	naireadblock32byslot, 1024, 1, do_naireadblock32byslot,
	"naireadblock utility command",
	"[slot id] [module offset start(32bit)] [Stride(MAX 1024)] [Count] [DataBuffer(32Bit)]"
);

U_BOOT_CMD(
	naiwriteblock16, 255, 1, do_naiwriteblock16,
	"naiwriteblock utility command",
	"[start_address(32bit)] [Stride(MAX 255)] [Count(MAX 255)] [Data1(32Bit)] [Data2(16Bit) ... DataN(16Bit)]"
);

U_BOOT_CMD(
	naiwriteblock16byslot, 255, 1, do_naiwriteblock16byslot,
	"naiwriteblock utility command",
	"[slot id] [module offset start(32bit)] [Stride(MAX 255)] [Count(MAX 255)] [Data1(16Bit) Data2(16Bit) ... DataN(16Bit)]"
);

U_BOOT_CMD(
	naiwriteblock16byslotauto, 5, 1, do_naiwriteblock16byslotauto,
	"naiwriteblock utility command",
	"[slot id] [module offset start(32bit)] [Stride(MAX 255)] [Count(MAX 1024)]"
);

U_BOOT_CMD(
	naireadblock16, 1024, 1, do_naireadblock16,
	"naireadblock utility command",
	"[start_address(32bit)] [Stride(MAX 255)] [Count(MAX 1024)] [DataBuffer(16Bit)]"
);

U_BOOT_CMD(
	naireadblock16byslot, 1024, 1, do_naireadblock16byslot,
	"naireadblock utility command",
	"[slot id] [module offset start(32bit)] [Stride(MAX 255)] [Count(MAX 1024)] [DataBuffer(16Bit)]"
);

U_BOOT_CMD(
	naiexitmodconfigmode, 2, 1, do_exitmodconfigmode,
	"Exits config mode for the given module",
	"[Module Slot ID (8bit - HEX)] **0xFF INDICATES ALL MODULES**"
);
	
U_BOOT_CMD(
	nairesetmodule, 2, 1, do_resetmodule,
	"Performs a CPU reset for the given module",
	"[Module Slot ID (8bit - HEX)] **0xFF INDICATES ALL MODULES**"
);

U_BOOT_CMD(
	naimoduleinit, 2, 1, do_initmodule,
	"Init All Module",
	" "
);

U_BOOT_CMD(
	naienablemodule, 2, 1, do_enablemodule,
	"Power ON given module slot",
	"[Module Slot ID (8bit - HEX)] **0xFF INDICATES ALL MODULES**"
);

U_BOOT_CMD(
	naidisablemodule, 2, 1, do_disablemodule,
	"Power OFF given module slot",
	"[Module Slot ID (8bit - HEX)] **0xFF INDICATES ALL MODULES**"
);

U_BOOT_CMD(
	naieraseflash, 4, 1, do_eraseflash,
	"Erases desired portion of flash",
	"[Module Slot ID (8bit - HEX)]"
	"[Offset (32bit - HEX)]"
	"[Num Pages (8bit - HEX) (Each page is 65536 bytes)]"
);

U_BOOT_CMD(
	naitestwriteblock, 5, 1, do_testwriteblock,
	"Tests the write block functionality",
	"[start_address(32bit)]"
	"[Stride(MAX 255)]"
	"[Count-(Base 10)]" 
	"[StartValue-(32bit - HEX)]"
);

U_BOOT_CMD(
	naitestreadblock, 5, 1, do_testreadblock,
	"Tests the read block functionality",
	"[start_address(32bit)]"
	"[Stride(MAX 255)]"
	"[Count-(Base 10)]" 
	"[StartValue-(32bit - HEX)]"
);

U_BOOT_CMD(
	naitestwrite, 5, 1, do_testwrite,
	"Tests the write functionality (using single writes)",
	"[start_address(32bit)]"
	"[Stride(MAX 255)]"
	"[Count-(Base 10)]" 
	"[StartValue-(32bit - HEX)]"
);

U_BOOT_CMD(	
	naitestdt2configbyslot, 3, 1, do_naitestdtconfigbyslot,
	"naitestdt2configbyslot utility command",
	"[Module Slot ID (8bit - HEX)]"	
	"[Channel 1 - 16 (8bit - DEC)]"
);

U_BOOT_CMD(	
	naitestdt2getbyslot, 3, 1, do_naitestdtgetbyslot,
	"naitestdt2getbyslot utility command",
	"[Module Slot ID (8bit - HEX)]"	
	"[Channel 1 - 16 (8bit - DEC)]"
);

U_BOOT_CMD(	
	naitestdt2erasebyslot, 3, 1, do_naitestdterasebyslot,
	"naitestdt2erasebyslot utility command",
	"[Module Slot ID (8bit - HEX)]"	
	"[Channel 1 - 16 (8bit - DEC)]"
);
#endif


